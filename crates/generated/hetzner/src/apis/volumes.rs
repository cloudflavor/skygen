// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListVolumesRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> ListVolumesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "volumes");

        Self { builder }
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_sort(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("sort", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_label_selector(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("label_selector", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get all Volumes
///
/// Gets all existing Volumes that you have available.
///
/// **HTTP Method:** `GET`
/// **Path:** `/volumes`
///
/// **Parameters**
/// - `status` (query,optional)
/// - `sort` (query,optional)
/// - `name` (query,optional)
/// - `label_selector` (query,optional)
/// - `page` (query,optional)
/// - `per_page` (query,optional)
///
/// # Example
/// ```no_run
/// use hetzner_cloud::{ ApiClient, apis::volumes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_volumes(&api)
///     .with_status("status")
///     .with_sort("sort")
///     .with_name("name")
///     .with_label_selector("label_selector")
///     .with_page("page")
///     .with_per_page("per_page")
///     .send()
///     .await?;
/// ```
pub fn list_volumes(api: &ApiClient) -> ListVolumesRequest<'_> {
    ListVolumesRequest::new(api)
}

#[derive(Debug)]
pub struct CreateVolumeRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> CreateVolumeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "volumes");

        Self { builder }
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Create a Volume
///
/// Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the `location` key instead of `server`. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.
///
/// Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the `next_actions` key in the response is an array which contains a single `attach_volume` action.
///
/// The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).
///
/// A volumeâ€™s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.
///
/// #### Call specific error codes
///
/// | Code                                | Description                                         |
/// |-------------------------------------|-----------------------------------------------------|
/// | `no_space_left_in_location`         | There is no volume space left in the given location |
///
/// **HTTP Method:** `POST`
/// **Path:** `/volumes`
///
/// # Example
/// ```no_run
/// use hetzner_cloud::{ ApiClient, apis::volumes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = create_volume(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_volume(api: &ApiClient) -> CreateVolumeRequest<'_> {
    CreateVolumeRequest::new(api)
}

#[derive(Debug)]
pub struct VolumeRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> VolumeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "volumes/{id}").require_path("id");

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get a Volume
///
/// Gets a specific Volume object.
///
/// **HTTP Method:** `GET`
/// **Path:** `/volumes/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use hetzner_cloud::{ ApiClient, apis::volumes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = volume(&api)
///     .with_id("id")
///     .send()
///     .await?;
/// ```
pub fn volume(api: &ApiClient) -> VolumeRequest<'_> {
    VolumeRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateVolumeRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> UpdateVolumeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PUT, "volumes/{id}").require_path("id");

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Update a Volume
///
/// Updates the Volume properties.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/volumes/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use hetzner_cloud::{ ApiClient, apis::volumes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = update_volume(&api)
///     .with_id("id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_volume(api: &ApiClient) -> UpdateVolumeRequest<'_> {
    UpdateVolumeRequest::new(api)
}

#[derive(Debug)]
pub struct VolumeDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> VolumeDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::DELETE, "volumes/{id}").require_path("id");

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Delete a Volume
///
/// Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/volumes/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use hetzner_cloud::{ ApiClient, apis::volumes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = volume_delete(&api)
///     .with_id("id")
///     .send()
///     .await?;
/// ```
pub fn volume_delete(api: &ApiClient) -> VolumeDeleteRequest<'_> {
    VolumeDeleteRequest::new(api)
}
