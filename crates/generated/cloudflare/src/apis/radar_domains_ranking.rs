// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct GetRankingDomainDetailsRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetRankingDomainDetailsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "radar/ranking/domain/{domain}")
            .require_path("domain");

        Self { builder }
    }
    pub fn with_domain(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("domain", value);
        self
    }
    pub fn with_limit(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("limit", value);
        self
    }
    pub fn with_ranking_type(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("rankingType", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_include_top_locations(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("includeTopLocations", value);
        self
    }
    pub fn with_date(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("date", value);
        self
    }
    pub fn with_format(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("format", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get domain rank details
///
/// Retrieves domain rank details. Cloudflare provides an ordered rank for the top 100 domains, but for the remainder it only provides ranking buckets like top 200 thousand, top one million, etc.. These are available through Radar datasets endpoints.
///
/// **HTTP Method:** `GET`
/// **Path:** `/radar/ranking/domain/{domain}`
///
/// **Parameters**
/// - `domain` (path, required)
/// - `limit` (query,optional)
/// - `rankingType` (query,optional)
/// - `name` (query,optional)
/// - `includeTopLocations` (query,optional)
/// - `date` (query,optional)
/// - `format` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::radar_domains_ranking };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_ranking_domain_details(&api)
///     .with_domain("domain")
///     .with_limit("limit")
///     .with_ranking_type("rankingType")
///     .with_name("name")
///     .with_include_top_locations("includeTopLocations")
///     .with_date("date")
///     .with_format("format")
///     .send()
///     .await?;
/// ```
pub fn get_ranking_domain_details(api: &ApiClient) -> GetRankingDomainDetailsRequest<'_> {
    GetRankingDomainDetailsRequest::new(api)
}

#[derive(Debug)]
pub struct GetRankingDomainTimeseriesRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetRankingDomainTimeseriesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "radar/ranking/timeseries_groups");

        Self { builder }
    }
    pub fn with_limit(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("limit", value);
        self
    }
    pub fn with_ranking_type(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("rankingType", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_location(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("location", value);
        self
    }
    pub fn with_domains(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("domains", value);
        self
    }
    pub fn with_domain_category(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("domainCategory", value);
        self
    }
    pub fn with_date_range(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("dateRange", value);
        self
    }
    pub fn with_date_start(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("dateStart", value);
        self
    }
    pub fn with_date_end(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("dateEnd", value);
        self
    }
    pub fn with_format(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("format", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get domains rank time series
///
/// Retrieves domains rank over time.
///
/// **HTTP Method:** `GET`
/// **Path:** `/radar/ranking/timeseries_groups`
///
/// **Parameters**
/// - `limit` (query,optional)
/// - `rankingType` (query,optional)
/// - `name` (query,optional)
/// - `location` (query,optional)
/// - `domains` (query,optional)
/// - `domainCategory` (query,optional)
/// - `dateRange` (query,optional)
/// - `dateStart` (query,optional)
/// - `dateEnd` (query,optional)
/// - `format` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::radar_domains_ranking };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_ranking_domain_timeseries(&api)
///     .with_limit("limit")
///     .with_ranking_type("rankingType")
///     .with_name("name")
///     .with_location("location")
///     .with_domains("domains")
///     .with_domain_category("domainCategory")
///     .with_date_range("dateRange")
///     .with_date_start("dateStart")
///     .with_date_end("dateEnd")
///     .with_format("format")
///     .send()
///     .await?;
/// ```
pub fn get_ranking_domain_timeseries(api: &ApiClient) -> GetRankingDomainTimeseriesRequest<'_> {
    GetRankingDomainTimeseriesRequest::new(api)
}

#[derive(Debug)]
pub struct GetRankingTopDomainsRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetRankingTopDomainsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "radar/ranking/top");

        Self { builder }
    }
    pub fn with_limit(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("limit", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_location(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("location", value);
        self
    }
    pub fn with_domain_category(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("domainCategory", value);
        self
    }
    pub fn with_date(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("date", value);
        self
    }
    pub fn with_ranking_type(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("rankingType", value);
        self
    }
    pub fn with_format(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("format", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get top or trending domains
///
/// Retrieves the top or trending domains based on their rank. Popular domains are domains of broad appeal based on how people use the Internet. Trending domains are domains that are generating a surge in interest. For more information on top domains, see <https://blog.cloudflare.com/radar-domain-rankings/.>
///
/// **HTTP Method:** `GET`
/// **Path:** `/radar/ranking/top`
///
/// **Parameters**
/// - `limit` (query,optional)
/// - `name` (query,optional)
/// - `location` (query,optional)
/// - `domainCategory` (query,optional)
/// - `date` (query,optional)
/// - `rankingType` (query,optional)
/// - `format` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::radar_domains_ranking };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_ranking_top_domains(&api)
///     .with_limit("limit")
///     .with_name("name")
///     .with_location("location")
///     .with_domain_category("domainCategory")
///     .with_date("date")
///     .with_ranking_type("rankingType")
///     .with_format("format")
///     .send()
///     .await?;
/// ```
pub fn get_ranking_top_domains(api: &ApiClient) -> GetRankingTopDomainsRequest<'_> {
    GetRankingTopDomainsRequest::new(api)
}
