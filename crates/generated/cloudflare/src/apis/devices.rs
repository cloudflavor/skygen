// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::teams_devices_api_response_single::TeamsDevicesApiResponseSingle;
use crate::models::teams_devices_default_device_settings_response::TeamsDevicesDefaultDeviceSettingsResponse;
use crate::models::teams_devices_device_response::TeamsDevicesDeviceResponse;
use crate::models::teams_devices_device_settings_response::TeamsDevicesDeviceSettingsResponse;
use crate::models::teams_devices_device_settings_response_collection::TeamsDevicesDeviceSettingsResponseCollection;
use crate::models::teams_devices_devices_policy_certificates_single::TeamsDevicesDevicesPolicyCertificatesSingle;
use crate::models::teams_devices_devices_response::TeamsDevicesDevicesResponse;
use crate::models::teams_devices_fallback_domain_response_collection::TeamsDevicesFallbackDomainResponseCollection;
use crate::models::teams_devices_override_codes_response::TeamsDevicesOverrideCodesResponse;
use crate::models::teams_devices_split_tunnel_include_response_collection::TeamsDevicesSplitTunnelIncludeResponseCollection;
use crate::models::teams_devices_split_tunnel_response_collection::TeamsDevicesSplitTunnelResponseCollection;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListDevicesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDevicesResponse>,
}

impl<'a> ListDevicesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/devices")
            .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDevicesResponse> {
        self.builder.send().await
    }
}
/// List devices (deprecated)
///
/// List WARP devices. Not supported when [multi-user mode](<https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/)> is enabled for the account.
///
/// **Deprecated**: please use one of the following endpoints instead:
/// - GET /accounts/{account_id}/devices/physical-devices
/// - GET /accounts/{account_id}/devices/registrations
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_devices(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn list_devices(api: &ApiClient) -> ListDevicesRequest<'_> {
    ListDevicesRequest::new(api)
}

#[derive(Debug)]
pub struct ListDeviceSettingsPoliciesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceSettingsResponseCollection>,
}

impl<'a> ListDeviceSettingsPoliciesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/devices/policies")
                .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceSettingsResponseCollection> {
        self.builder.send().await
    }
}
/// List device settings profiles
///
/// Fetches a list of the device settings profiles for an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policies`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_device_settings_policies(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn list_device_settings_policies(api: &ApiClient) -> ListDeviceSettingsPoliciesRequest<'_> {
    ListDeviceSettingsPoliciesRequest::new(api)
}

#[derive(Debug)]
pub struct GetDefaultDeviceSettingsRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDefaultDeviceSettingsResponse>,
}

impl<'a> GetDefaultDeviceSettingsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/devices/policy")
                .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDefaultDeviceSettingsResponse> {
        self.builder.send().await
    }
}
/// Get the default device settings profile
///
/// Fetches the default device settings profile for an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_default_device_settings(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn get_default_device_settings(api: &ApiClient) -> GetDefaultDeviceSettingsRequest<'_> {
    GetDefaultDeviceSettingsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateDeviceSettingsPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceSettingsResponse>,
}

impl<'a> CreateDeviceSettingsPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "accounts/{account_id}/devices/policy")
                .require_path("account_id")
                .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceSettingsResponse> {
        self.builder.send().await
    }
}
/// Create a device settings profile
///
/// Creates a device settings profile to be applied to certain devices matching the criteria.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/devices/policy`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_device_settings_policy(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_device_settings_policy(api: &ApiClient) -> CreateDeviceSettingsPolicyRequest<'_> {
    CreateDeviceSettingsPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateDefaultDeviceSettingsRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDefaultDeviceSettingsResponse>,
}

impl<'a> UpdateDefaultDeviceSettingsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PATCH, "accounts/{account_id}/devices/policy")
                .require_path("account_id")
                .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDefaultDeviceSettingsResponse> {
        self.builder.send().await
    }
}
/// Update the default device settings profile
///
/// Updates the default device settings profile for an account.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/accounts/{account_id}/devices/policy`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_default_device_settings(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_default_device_settings(api: &ApiClient) -> UpdateDefaultDeviceSettingsRequest<'_> {
    UpdateDefaultDeviceSettingsRequest::new(api)
}

#[derive(Debug)]
pub struct GetSplitTunnelExcludeRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelResponseCollection>,
}

impl<'a> GetSplitTunnelExcludeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/exclude",
        )
        .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// Get the Split Tunnel exclude list
///
/// Fetches the list of routes excluded from the WARP client's tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/exclude`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_split_tunnel_exclude(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn get_split_tunnel_exclude(api: &ApiClient) -> GetSplitTunnelExcludeRequest<'_> {
    GetSplitTunnelExcludeRequest::new(api)
}

#[derive(Debug)]
pub struct SetSplitTunnelExcludeRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelResponseCollection>,
}

impl<'a> SetSplitTunnelExcludeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/exclude",
        )
        .require_path("account_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<crate::models::teams_devices_split_tunnel::TeamsDevicesSplitTunnel>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// Set the Split Tunnel exclude list
///
/// Sets the list of routes excluded from the WARP client's tunnel.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/exclude`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_split_tunnel::TeamsDevicesSplitTunnel> = todo!();
/// let response = set_split_tunnel_exclude(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_split_tunnel_exclude(api: &ApiClient) -> SetSplitTunnelExcludeRequest<'_> {
    SetSplitTunnelExcludeRequest::new(api)
}

#[derive(Debug)]
pub struct GetLocalDomainFallbackRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesFallbackDomainResponseCollection>,
}

impl<'a> GetLocalDomainFallbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/fallback_domains",
        )
        .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesFallbackDomainResponseCollection> {
        self.builder.send().await
    }
}
/// Get your Local Domain Fallback list
///
/// Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/fallback_domains`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_local_domain_fallback(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn get_local_domain_fallback(api: &ApiClient) -> GetLocalDomainFallbackRequest<'_> {
    GetLocalDomainFallbackRequest::new(api)
}

#[derive(Debug)]
pub struct SetLocalDomainFallbackRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesFallbackDomainResponseCollection>,
}

impl<'a> SetLocalDomainFallbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/fallback_domains",
        )
        .require_path("account_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<crate::models::teams_devices_fallback_domain::TeamsDevicesFallbackDomain>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesFallbackDomainResponseCollection> {
        self.builder.send().await
    }
}
/// Set your Local Domain Fallback list
///
/// Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/fallback_domains`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_fallback_domain::TeamsDevicesFallbackDomain> = todo!();
/// let response = set_local_domain_fallback(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_local_domain_fallback(api: &ApiClient) -> SetLocalDomainFallbackRequest<'_> {
    SetLocalDomainFallbackRequest::new(api)
}

#[derive(Debug)]
pub struct GetSplitTunnelIncludeRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelIncludeResponseCollection>,
}

impl<'a> GetSplitTunnelIncludeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/include",
        )
        .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelIncludeResponseCollection> {
        self.builder.send().await
    }
}
/// Get the Split Tunnel include list
///
/// Fetches the list of routes included in the WARP client's tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/include`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_split_tunnel_include(&api)
///     .with_account_id("account_id")
///     .send()
///     .await?;
/// ```
pub fn get_split_tunnel_include(api: &ApiClient) -> GetSplitTunnelIncludeRequest<'_> {
    GetSplitTunnelIncludeRequest::new(api)
}

#[derive(Debug)]
pub struct SetSplitTunnelIncludeRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelIncludeResponseCollection>,
}

impl<'a> SetSplitTunnelIncludeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/include",
        )
        .require_path("account_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<
            crate::models::teams_devices_split_tunnel_include::TeamsDevicesSplitTunnelInclude,
        >,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelIncludeResponseCollection> {
        self.builder.send().await
    }
}
/// Set the Split Tunnel include list
///
/// Sets the list of routes included in the WARP client's tunnel.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/include`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_split_tunnel_include::TeamsDevicesSplitTunnelInclude> = todo!();
/// let response = set_split_tunnel_include(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_split_tunnel_include(api: &ApiClient) -> SetSplitTunnelIncludeRequest<'_> {
    SetSplitTunnelIncludeRequest::new(api)
}

#[derive(Debug)]
pub struct GetDeviceSettingsPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceSettingsResponse>,
}

impl<'a> GetDeviceSettingsPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/{policy_id}",
        )
        .require_path("account_id")
        .require_path("policy_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceSettingsResponse> {
        self.builder.send().await
    }
}
/// Get device settings profile by ID
///
/// Fetches a device settings profile by ID.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_device_settings_policy(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .send()
///     .await?;
/// ```
pub fn get_device_settings_policy(api: &ApiClient) -> GetDeviceSettingsPolicyRequest<'_> {
    GetDeviceSettingsPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteDeviceSettingsPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceSettingsResponseCollection>,
}

impl<'a> DeleteDeviceSettingsPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/devices/policy/{policy_id}",
        )
        .require_path("account_id")
        .require_path("policy_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceSettingsResponseCollection> {
        self.builder.send().await
    }
}
/// Delete a device settings profile
///
/// Deletes a device settings profile and fetches a list of the remaining profiles for an account.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = delete_device_settings_policy(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .send()
///     .await?;
/// ```
pub fn delete_device_settings_policy(api: &ApiClient) -> DeleteDeviceSettingsPolicyRequest<'_> {
    DeleteDeviceSettingsPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateDeviceSettingsPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceSettingsResponse>,
}

impl<'a> UpdateDeviceSettingsPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "accounts/{account_id}/devices/policy/{policy_id}",
        )
        .require_path("account_id")
        .require_path("policy_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceSettingsResponse> {
        self.builder.send().await
    }
}
/// Update a device settings profile
///
/// Updates a configured device settings profile.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_device_settings_policy(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_device_settings_policy(api: &ApiClient) -> UpdateDeviceSettingsPolicyRequest<'_> {
    UpdateDeviceSettingsPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct GetSplitTunnelExcludeGetRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelResponseCollection>,
}

impl<'a> GetSplitTunnelExcludeGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/{policy_id}/exclude",
        )
        .require_path("account_id")
        .require_path("policy_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// Get the Split Tunnel exclude list for a device settings profile
///
/// Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/exclude`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_split_tunnel_exclude_get(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .send()
///     .await?;
/// ```
pub fn get_split_tunnel_exclude_get(api: &ApiClient) -> GetSplitTunnelExcludeGetRequest<'_> {
    GetSplitTunnelExcludeGetRequest::new(api)
}

#[derive(Debug)]
pub struct SetSplitTunnelExcludePutRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelResponseCollection>,
}

impl<'a> SetSplitTunnelExcludePutRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/{policy_id}/exclude",
        )
        .require_path("account_id")
        .require_path("policy_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<crate::models::teams_devices_split_tunnel::TeamsDevicesSplitTunnel>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// Set the Split Tunnel exclude list for a device settings profile
///
/// Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/exclude`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_split_tunnel::TeamsDevicesSplitTunnel> = todo!();
/// let response = set_split_tunnel_exclude_put(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_split_tunnel_exclude_put(api: &ApiClient) -> SetSplitTunnelExcludePutRequest<'_> {
    SetSplitTunnelExcludePutRequest::new(api)
}

#[derive(Debug)]
pub struct GetLocalDomainFallbackGetRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesFallbackDomainResponseCollection>,
}

impl<'a> GetLocalDomainFallbackGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/{policy_id}/fallback_domains",
        )
        .require_path("account_id")
        .require_path("policy_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesFallbackDomainResponseCollection> {
        self.builder.send().await
    }
}
/// Get the Local Domain Fallback list for a device settings profile
///
/// Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/fallback_domains`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_local_domain_fallback_get(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .send()
///     .await?;
/// ```
pub fn get_local_domain_fallback_get(api: &ApiClient) -> GetLocalDomainFallbackGetRequest<'_> {
    GetLocalDomainFallbackGetRequest::new(api)
}

#[derive(Debug)]
pub struct SetLocalDomainFallbackPutRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesFallbackDomainResponseCollection>,
}

impl<'a> SetLocalDomainFallbackPutRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/{policy_id}/fallback_domains",
        )
        .require_path("account_id")
        .require_path("policy_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<crate::models::teams_devices_fallback_domain::TeamsDevicesFallbackDomain>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesFallbackDomainResponseCollection> {
        self.builder.send().await
    }
}
/// Set the Local Domain Fallback list for a device settings profile
///
/// Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/fallback_domains`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_fallback_domain::TeamsDevicesFallbackDomain> = todo!();
/// let response = set_local_domain_fallback_put(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_local_domain_fallback_put(api: &ApiClient) -> SetLocalDomainFallbackPutRequest<'_> {
    SetLocalDomainFallbackPutRequest::new(api)
}

#[derive(Debug)]
pub struct GetSplitTunnelIncludeGetRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelIncludeResponseCollection>,
}

impl<'a> GetSplitTunnelIncludeGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/policy/{policy_id}/include",
        )
        .require_path("account_id")
        .require_path("policy_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelIncludeResponseCollection> {
        self.builder.send().await
    }
}
/// Get the Split Tunnel include list for a device settings profile
///
/// Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/include`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_split_tunnel_include_get(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .send()
///     .await?;
/// ```
pub fn get_split_tunnel_include_get(api: &ApiClient) -> GetSplitTunnelIncludeGetRequest<'_> {
    GetSplitTunnelIncludeGetRequest::new(api)
}

#[derive(Debug)]
pub struct SetSplitTunnelIncludePutRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesSplitTunnelIncludeResponseCollection>,
}

impl<'a> SetSplitTunnelIncludePutRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/devices/policy/{policy_id}/include",
        )
        .require_path("account_id")
        .require_path("policy_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("policy_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: Vec<
            crate::models::teams_devices_split_tunnel_include::TeamsDevicesSplitTunnelInclude,
        >,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesSplitTunnelIncludeResponseCollection> {
        self.builder.send().await
    }
}
/// Set the Split Tunnel include list for a device settings profile
///
/// Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/devices/policy/{policy_id}/include`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `policy_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: Vec<crate::models::teams_devices_split_tunnel_include::TeamsDevicesSplitTunnelInclude> = todo!();
/// let response = set_split_tunnel_include_put(&api)
///     .with_account_id("account_id")
///     .with_policy_id("policy_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_split_tunnel_include_put(api: &ApiClient) -> SetSplitTunnelIncludePutRequest<'_> {
    SetSplitTunnelIncludePutRequest::new(api)
}

#[derive(Debug)]
pub struct RevokeDevicesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesApiResponseSingle>,
}

impl<'a> RevokeDevicesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "accounts/{account_id}/devices/revoke")
                .require_path("account_id")
                .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::teams_devices_revoke_devices_request::TeamsDevicesRevokeDevicesRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesApiResponseSingle> {
        self.builder.send().await
    }
}
/// Revoke devices (deprecated)
///
/// Revokes a list of devices. Not supported when [multi-user mode](<https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/)> is enabled.
///
/// **Deprecated**: please use POST /accounts/{account_id}/devices/registrations/revoke instead.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/devices/revoke`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: crate::models::teams_devices_revoke_devices_request::TeamsDevicesRevokeDevicesRequest = todo!();
/// let response = revoke_devices(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn revoke_devices(api: &ApiClient) -> RevokeDevicesRequest<'_> {
    RevokeDevicesRequest::new(api)
}

#[derive(Debug)]
pub struct UnrevokeDevicesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesApiResponseSingle>,
}

impl<'a> UnrevokeDevicesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "accounts/{account_id}/devices/unrevoke")
                .require_path("account_id")
                .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::teams_devices_unrevoke_devices_request::TeamsDevicesUnrevokeDevicesRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesApiResponseSingle> {
        self.builder.send().await
    }
}
/// Unrevoke devices (deprecated)
///
/// Unrevokes a list of devices. Not supported when [multi-user mode](<https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/)> is enabled.
///
/// **Deprecated**: please use POST /accounts/{account_id}/devices/registrations/unrevoke instead.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/devices/unrevoke`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: crate::models::teams_devices_unrevoke_devices_request::TeamsDevicesUnrevokeDevicesRequest = todo!();
/// let response = unrevoke_devices(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn unrevoke_devices(api: &ApiClient) -> UnrevokeDevicesRequest<'_> {
    UnrevokeDevicesRequest::new(api)
}

#[derive(Debug)]
pub struct DeviceDetailsRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDeviceResponse>,
}

impl<'a> DeviceDetailsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/{device_id}",
        )
        .require_path("account_id")
        .require_path("device_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_device_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("device_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDeviceResponse> {
        self.builder.send().await
    }
}
/// Get device (deprecated)
///
/// Fetches a single WARP device. Not supported when [multi-user mode](<https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/)> is enabled for the account.
///
/// **Deprecated**: please use one of the following endpoints instead:
/// - GET /accounts/{account_id}/devices/physical-devices/{device_id}
/// - GET /accounts/{account_id}/devices/registrations/{registration_id}
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/{device_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `device_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = device_details(&api)
///     .with_account_id("account_id")
///     .with_device_id("device_id")
///     .send()
///     .await?;
/// ```
pub fn device_details(api: &ApiClient) -> DeviceDetailsRequest<'_> {
    DeviceDetailsRequest::new(api)
}

#[derive(Debug)]
pub struct ListAdminOverrideCodeRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesOverrideCodesResponse>,
}

impl<'a> ListAdminOverrideCodeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/devices/{device_id}/override_codes",
        )
        .require_path("account_id")
        .require_path("device_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_device_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("device_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesOverrideCodesResponse> {
        self.builder.send().await
    }
}
/// Get override codes (deprecated)

///
/// Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration. Not supported when [multi-user mode](<https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/)> is enabled for the account.
/// **Deprecated:** please use GET /accounts/{account_id}/devices/registrations/{registration_id}/override_codes instead.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/devices/{device_id}/override_codes`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `device_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_admin_override_code(&api)
///     .with_account_id("account_id")
///     .with_device_id("device_id")
///     .send()
///     .await?;
/// ```
pub fn list_admin_override_code(api: &ApiClient) -> ListAdminOverrideCodeRequest<'_> {
    ListAdminOverrideCodeRequest::new(api)
}

#[derive(Debug)]
pub struct GetPolicyCertificatesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDevicesPolicyCertificatesSingle>,
}

impl<'a> GetPolicyCertificatesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/devices/policy/certificates",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDevicesPolicyCertificatesSingle> {
        self.builder.send().await
    }
}
/// Get device certificate provisioning status
///
/// Fetches device certificate provisioning.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/devices/policy/certificates`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_policy_certificates(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_policy_certificates(api: &ApiClient) -> GetPolicyCertificatesRequest<'_> {
    GetPolicyCertificatesRequest::new(api)
}

#[derive(Debug)]
pub struct UpdatePolicyCertificatesRequest<'a> {
    builder: ApiRequestBuilder<'a, TeamsDevicesDevicesPolicyCertificatesSingle>,
}

impl<'a> UpdatePolicyCertificatesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/devices/policy/certificates",
        )
        .require_path("zone_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::teams_devices_devices_policy_certificates::TeamsDevicesDevicesPolicyCertificates,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TeamsDevicesDevicesPolicyCertificatesSingle> {
        self.builder.send().await
    }
}
/// Update device certificate provisioning status
///
/// Enable Zero Trust Clients to provision a certificate, containing a x509 subject, and referenced by Access device posture policies when the client visits MTLS protected domains. This facilitates device posture without a WARP session.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/devices/policy/certificates`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::devices };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: crate::models::teams_devices_devices_policy_certificates::TeamsDevicesDevicesPolicyCertificates = todo!();
/// let response = update_policy_certificates(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_policy_certificates(api: &ApiClient) -> UpdatePolicyCertificatesRequest<'_> {
    UpdatePolicyCertificatesRequest::new(api)
}
