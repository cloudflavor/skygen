// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::tunnel_empty_response::TunnelEmptyResponse;
use crate::models::tunnel_tunnel_client_response::TunnelTunnelClientResponse;
use crate::models::tunnel_tunnel_connections_response::TunnelTunnelConnectionsResponse;
use crate::models::tunnel_tunnel_response_collection::TunnelTunnelResponseCollection;
use crate::models::tunnel_tunnel_response_single::TunnelTunnelResponseSingle;
use crate::models::tunnel_tunnel_response_token::TunnelTunnelResponseToken;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListCloudflareTunnelsRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseCollection>,
}

impl<'a> ListCloudflareTunnelsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/cfd_tunnel")
            .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_is_deleted(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("is_deleted", value);
        self
    }
    pub fn with_existed_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("existed_at", value);
        self
    }
    pub fn with_uuid(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("uuid", value);
        self
    }
    pub fn with_was_active_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_active_at", value);
        self
    }
    pub fn with_was_inactive_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_inactive_at", value);
        self
    }
    pub fn with_include_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("include_prefix", value);
        self
    }
    pub fn with_exclude_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("exclude_prefix", value);
        self
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// List Cloudflare Tunnels
///
/// Lists and filters Cloudflare Tunnels in an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/cfd_tunnel`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `name` (query,optional)
/// - `is_deleted` (query,optional)
/// - `existed_at` (query,optional)
/// - `uuid` (query,optional)
/// - `was_active_at` (query,optional)
/// - `was_inactive_at` (query,optional)
/// - `include_prefix` (query,optional)
/// - `exclude_prefix` (query,optional)
/// - `status` (query,optional)
/// - `per_page` (query,optional)
/// - `page` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_cloudflare_tunnels(&api)
///     .with_account_id("account_id")
///     .with_name("name")
///     .with_is_deleted("is_deleted")
///     .with_existed_at("existed_at")
///     .with_uuid("uuid")
///     .with_was_active_at("was_active_at")
///     .with_was_inactive_at("was_inactive_at")
///     .with_include_prefix("include_prefix")
///     .with_exclude_prefix("exclude_prefix")
///     .with_status("status")
///     .with_per_page("per_page")
///     .with_page("page")
///     .send()
///     .await?;
/// ```
pub fn list_cloudflare_tunnels(api: &ApiClient) -> ListCloudflareTunnelsRequest<'_> {
    ListCloudflareTunnelsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateCloudflareTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> CreateCloudflareTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "accounts/{account_id}/cfd_tunnel")
            .require_path("account_id")
            .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Create a Cloudflare Tunnel
///
/// Creates a new Cloudflare Tunnel in an account.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/cfd_tunnel`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_cloudflare_tunnel(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_cloudflare_tunnel(api: &ApiClient) -> CreateCloudflareTunnelRequest<'_> {
    CreateCloudflareTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct GetCloudflareTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> GetCloudflareTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Get a Cloudflare Tunnel
///
/// Fetches a single Cloudflare Tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_cloudflare_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .send()
///     .await?;
/// ```
pub fn get_cloudflare_tunnel(api: &ApiClient) -> GetCloudflareTunnelRequest<'_> {
    GetCloudflareTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteCloudflareTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> DeleteCloudflareTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Delete a Cloudflare Tunnel
///
/// Deletes a Cloudflare Tunnel from an account.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = delete_cloudflare_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn delete_cloudflare_tunnel(api: &ApiClient) -> DeleteCloudflareTunnelRequest<'_> {
    DeleteCloudflareTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateCloudflareTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> UpdateCloudflareTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Update a Cloudflare Tunnel
///
/// Updates an existing Cloudflare Tunnel.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_cloudflare_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_cloudflare_tunnel(api: &ApiClient) -> UpdateCloudflareTunnelRequest<'_> {
    UpdateCloudflareTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct ListCloudflareTunnelConnectionsRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelConnectionsResponse>,
}

impl<'a> ListCloudflareTunnelConnectionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections",
        )
        .require_path("account_id")
        .require_path("tunnel_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelConnectionsResponse> {
        self.builder.send().await
    }
}
/// List Cloudflare Tunnel connections
///
/// Fetches connection details for a Cloudflare Tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_cloudflare_tunnel_connections(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .send()
///     .await?;
/// ```
pub fn list_cloudflare_tunnel_connections(
    api: &ApiClient,
) -> ListCloudflareTunnelConnectionsRequest<'_> {
    ListCloudflareTunnelConnectionsRequest::new(api)
}

#[derive(Debug)]
pub struct CleanUpCloudflareTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelEmptyResponse>,
}

impl<'a> CleanUpCloudflareTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_client_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("client_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelEmptyResponse> {
        self.builder.send().await
    }
}
/// Clean up Cloudflare Tunnel connections
///
/// Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
/// - `client_id` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = clean_up_cloudflare_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_client_id("client_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn clean_up_cloudflare_tunnel(api: &ApiClient) -> CleanUpCloudflareTunnelRequest<'_> {
    CleanUpCloudflareTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct GetCloudflareTunnelConnectorRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelClientResponse>,
}

impl<'a> GetCloudflareTunnelConnectorRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}/connectors/{connector_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_path("connector_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_connector_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("connector_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelClientResponse> {
        self.builder.send().await
    }
}
/// Get Cloudflare Tunnel connector
///
/// Fetches connector and connection details for a Cloudflare Tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connectors/{connector_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
/// - `connector_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_cloudflare_tunnel_connector(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_connector_id("connector_id")
///     .send()
///     .await?;
/// ```
pub fn get_cloudflare_tunnel_connector(api: &ApiClient) -> GetCloudflareTunnelConnectorRequest<'_> {
    GetCloudflareTunnelConnectorRequest::new(api)
}

#[derive(Debug)]
pub struct GetCloudflareTunnelManagementRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseToken>,
}

impl<'a> GetCloudflareTunnelManagementRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}/management",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseToken> {
        self.builder.send().await
    }
}
/// Get a Cloudflare Tunnel management token
///
/// Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}/management`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = get_cloudflare_tunnel_management(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn get_cloudflare_tunnel_management(
    api: &ApiClient,
) -> GetCloudflareTunnelManagementRequest<'_> {
    GetCloudflareTunnelManagementRequest::new(api)
}

#[derive(Debug)]
pub struct GetCloudflareTunnelTokenRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseToken>,
}

impl<'a> GetCloudflareTunnelTokenRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/cfd_tunnel/{tunnel_id}/token",
        )
        .require_path("account_id")
        .require_path("tunnel_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseToken> {
        self.builder.send().await
    }
}
/// Get a Cloudflare Tunnel token
///
/// Gets the token used to associate cloudflared with a specific tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/cfd_tunnel/{tunnel_id}/token`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_cloudflare_tunnel_token(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .send()
///     .await?;
/// ```
pub fn get_cloudflare_tunnel_token(api: &ApiClient) -> GetCloudflareTunnelTokenRequest<'_> {
    GetCloudflareTunnelTokenRequest::new(api)
}

#[derive(Debug)]
pub struct ListAllTunnelsRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseCollection>,
}

impl<'a> ListAllTunnelsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/tunnels")
            .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_is_deleted(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("is_deleted", value);
        self
    }
    pub fn with_existed_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("existed_at", value);
        self
    }
    pub fn with_uuid(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("uuid", value);
        self
    }
    pub fn with_was_active_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_active_at", value);
        self
    }
    pub fn with_was_inactive_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_inactive_at", value);
        self
    }
    pub fn with_include_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("include_prefix", value);
        self
    }
    pub fn with_exclude_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("exclude_prefix", value);
        self
    }
    pub fn with_tun_types(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tun_types", value);
        self
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// List All Tunnels
///
/// Lists and filters all types of Tunnels in an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/tunnels`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `name` (query,optional)
/// - `is_deleted` (query,optional)
/// - `existed_at` (query,optional)
/// - `uuid` (query,optional)
/// - `was_active_at` (query,optional)
/// - `was_inactive_at` (query,optional)
/// - `include_prefix` (query,optional)
/// - `exclude_prefix` (query,optional)
/// - `tun_types` (query,optional)
/// - `status` (query,optional)
/// - `per_page` (query,optional)
/// - `page` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_all_tunnels(&api)
///     .with_account_id("account_id")
///     .with_name("name")
///     .with_is_deleted("is_deleted")
///     .with_existed_at("existed_at")
///     .with_uuid("uuid")
///     .with_was_active_at("was_active_at")
///     .with_was_inactive_at("was_inactive_at")
///     .with_include_prefix("include_prefix")
///     .with_exclude_prefix("exclude_prefix")
///     .with_tun_types("tun_types")
///     .with_status("status")
///     .with_per_page("per_page")
///     .with_page("page")
///     .send()
///     .await?;
/// ```
pub fn list_all_tunnels(api: &ApiClient) -> ListAllTunnelsRequest<'_> {
    ListAllTunnelsRequest::new(api)
}

#[derive(Debug)]
pub struct ListWarpConnectorTunnelsRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseCollection>,
}

impl<'a> ListWarpConnectorTunnelsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "accounts/{account_id}/warp_connector")
                .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_is_deleted(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("is_deleted", value);
        self
    }
    pub fn with_existed_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("existed_at", value);
        self
    }
    pub fn with_uuid(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("uuid", value);
        self
    }
    pub fn with_was_active_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_active_at", value);
        self
    }
    pub fn with_was_inactive_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("was_inactive_at", value);
        self
    }
    pub fn with_include_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("include_prefix", value);
        self
    }
    pub fn with_exclude_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("exclude_prefix", value);
        self
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseCollection> {
        self.builder.send().await
    }
}
/// List Warp Connector Tunnels
///
/// Lists and filters Warp Connector Tunnels in an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/warp_connector`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `name` (query,optional)
/// - `is_deleted` (query,optional)
/// - `existed_at` (query,optional)
/// - `uuid` (query,optional)
/// - `was_active_at` (query,optional)
/// - `was_inactive_at` (query,optional)
/// - `include_prefix` (query,optional)
/// - `exclude_prefix` (query,optional)
/// - `status` (query,optional)
/// - `per_page` (query,optional)
/// - `page` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_warp_connector_tunnels(&api)
///     .with_account_id("account_id")
///     .with_name("name")
///     .with_is_deleted("is_deleted")
///     .with_existed_at("existed_at")
///     .with_uuid("uuid")
///     .with_was_active_at("was_active_at")
///     .with_was_inactive_at("was_inactive_at")
///     .with_include_prefix("include_prefix")
///     .with_exclude_prefix("exclude_prefix")
///     .with_status("status")
///     .with_per_page("per_page")
///     .with_page("page")
///     .send()
///     .await?;
/// ```
pub fn list_warp_connector_tunnels(api: &ApiClient) -> ListWarpConnectorTunnelsRequest<'_> {
    ListWarpConnectorTunnelsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateWarpConnectorTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> CreateWarpConnectorTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "accounts/{account_id}/warp_connector")
                .require_path("account_id")
                .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Create a Warp Connector Tunnel
///
/// Creates a new Warp Connector Tunnel in an account.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/warp_connector`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_warp_connector_tunnel(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_warp_connector_tunnel(api: &ApiClient) -> CreateWarpConnectorTunnelRequest<'_> {
    CreateWarpConnectorTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct GetWarpConnectorTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> GetWarpConnectorTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/warp_connector/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Get a Warp Connector Tunnel
///
/// Fetches a single Warp Connector Tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/warp_connector/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_warp_connector_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .send()
///     .await?;
/// ```
pub fn get_warp_connector_tunnel(api: &ApiClient) -> GetWarpConnectorTunnelRequest<'_> {
    GetWarpConnectorTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteWarpConnectorTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> DeleteWarpConnectorTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/warp_connector/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Delete a Warp Connector Tunnel
///
/// Deletes a Warp Connector Tunnel from an account.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/warp_connector/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = delete_warp_connector_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn delete_warp_connector_tunnel(api: &ApiClient) -> DeleteWarpConnectorTunnelRequest<'_> {
    DeleteWarpConnectorTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateWarpConnectorTunnelRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseSingle>,
}

impl<'a> UpdateWarpConnectorTunnelRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "accounts/{account_id}/warp_connector/{tunnel_id}",
        )
        .require_path("account_id")
        .require_path("tunnel_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseSingle> {
        self.builder.send().await
    }
}
/// Update a Warp Connector Tunnel
///
/// Updates an existing Warp Connector Tunnel.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/accounts/{account_id}/warp_connector/{tunnel_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_warp_connector_tunnel(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_warp_connector_tunnel(api: &ApiClient) -> UpdateWarpConnectorTunnelRequest<'_> {
    UpdateWarpConnectorTunnelRequest::new(api)
}

#[derive(Debug)]
pub struct GetWarpConnectorTunnelGetRequest<'a> {
    builder: ApiRequestBuilder<'a, TunnelTunnelResponseToken>,
}

impl<'a> GetWarpConnectorTunnelGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/warp_connector/{tunnel_id}/token",
        )
        .require_path("account_id")
        .require_path("tunnel_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_tunnel_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("tunnel_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TunnelTunnelResponseToken> {
        self.builder.send().await
    }
}
/// Get a Warp Connector Tunnel token
///
/// Gets the token used to associate warp device with a specific Warp Connector tunnel.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/warp_connector/{tunnel_id}/token`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `tunnel_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::cloudflare_tunnel };
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_warp_connector_tunnel_get(&api)
///     .with_account_id("account_id")
///     .with_tunnel_id("tunnel_id")
///     .send()
///     .await?;
/// ```
pub fn get_warp_connector_tunnel_get(api: &ApiClient) -> GetWarpConnectorTunnelGetRequest<'_> {
    GetWarpConnectorTunnelGetRequest::new(api)
}
