// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::tls_certificates_and_hostnames_custom_hostname_response_collection::TlsCertificatesAndHostnamesCustomHostnameResponseCollection;
use crate::models::tls_certificates_and_hostnames_custom_hostname_response_single::TlsCertificatesAndHostnamesCustomHostnameResponseSingle;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListCustomHostnamesRequest<'a> {
    builder: ApiRequestBuilder<'a, TlsCertificatesAndHostnamesCustomHostnameResponseCollection>,
}

impl<'a> ListCustomHostnamesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/custom_hostnames")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_hostname(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("hostname", value);
        self
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("id", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_order(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order", value);
        self
    }
    pub fn with_direction(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("direction", value);
        self
    }
    pub fn with_ssl(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("ssl", value);
        self
    }
    pub async fn send(
        self,
    ) -> ApiResult<TlsCertificatesAndHostnamesCustomHostnameResponseCollection> {
        self.builder.send().await
    }
}
/// List Custom Hostnames
///
/// List, search, sort, and filter all of your custom hostnames.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/custom_hostnames`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `hostname` (query,optional)
/// - `id` (query,optional)
/// - `page` (query,optional)
/// - `per_page` (query,optional)
/// - `order` (query,optional)
/// - `direction` (query,optional)
/// - `ssl` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = list_custom_hostnames(&api)
///     .with_zone_id("zone_id")
///     .with_hostname("hostname")
///     .with_id("id")
///     .with_page("page")
///     .with_per_page("per_page")
///     .with_order("order")
///     .with_direction("direction")
///     .with_ssl("ssl")
///     .send()
///     .await?;
/// ```
pub fn list_custom_hostnames(api: &ApiClient) -> ListCustomHostnamesRequest<'_> {
    ListCustomHostnamesRequest::new(api)
}

#[derive(Debug)]
pub struct CreateCustomHostnameRequest<'a> {
    builder: ApiRequestBuilder<'a, TlsCertificatesAndHostnamesCustomHostnameResponseSingle>,
}

impl<'a> CreateCustomHostnameRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "zones/{zone_id}/custom_hostnames")
            .require_path("zone_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TlsCertificatesAndHostnamesCustomHostnameResponseSingle> {
        self.builder.send().await
    }
}
/// Create Custom Hostname
///
/// Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with 'http' recommended if the CNAME is already in place (or will be soon). Specifying 'email' will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).  Enable bundling of certificates using the custom_cert_bundle field. The bundling process requires the following condition One certificate in the bundle must use an RSA, and the other must use an ECDSA.
///
/// **HTTP Method:** `POST`
/// **Path:** `/zones/{zone_id}/custom_hostnames`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_custom_hostname(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_custom_hostname(api: &ApiClient) -> CreateCustomHostnameRequest<'_> {
    CreateCustomHostnameRequest::new(api)
}

#[derive(Debug)]
pub struct DetailsRequest<'a> {
    builder: ApiRequestBuilder<'a, TlsCertificatesAndHostnamesCustomHostnameResponseSingle>,
}

impl<'a> DetailsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/custom_hostnames/{custom_hostname_id}",
        )
        .require_path("zone_id")
        .require_path("custom_hostname_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_custom_hostname_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("custom_hostname_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<TlsCertificatesAndHostnamesCustomHostnameResponseSingle> {
        self.builder.send().await
    }
}
/// Custom Hostname Details
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/custom_hostnames/{custom_hostname_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `custom_hostname_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = details(&api)
///     .with_zone_id("zone_id")
///     .with_custom_hostname_id("custom_hostname_id")
///     .send()
///     .await?;
/// ```
pub fn details(api: &ApiClient) -> DetailsRequest<'_> {
    DetailsRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteCustomHostnameAnyRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> DeleteCustomHostnameAnyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "zones/{zone_id}/custom_hostnames/{custom_hostname_id}",
        )
        .require_path("zone_id")
        .require_path("custom_hostname_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_custom_hostname_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("custom_hostname_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Delete Custom Hostname (and any issued SSL certificates)
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/zones/{zone_id}/custom_hostnames/{custom_hostname_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `custom_hostname_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = delete_custom_hostname_any(&api)
///     .with_zone_id("zone_id")
///     .with_custom_hostname_id("custom_hostname_id")
///     .send()
///     .await?;
/// ```
pub fn delete_custom_hostname_any(api: &ApiClient) -> DeleteCustomHostnameAnyRequest<'_> {
    DeleteCustomHostnameAnyRequest::new(api)
}

#[derive(Debug)]
pub struct EditCustomHostnameRequest<'a> {
    builder: ApiRequestBuilder<'a, TlsCertificatesAndHostnamesCustomHostnameResponseSingle>,
}

impl<'a> EditCustomHostnameRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/custom_hostnames/{custom_hostname_id}",
        )
        .require_path("zone_id")
        .require_path("custom_hostname_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_custom_hostname_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("custom_hostname_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<TlsCertificatesAndHostnamesCustomHostnameResponseSingle> {
        self.builder.send().await
    }
}
/// Edit Custom Hostname
///
/// Modify SSL configuration for a custom hostname. When sent with SSL config that matches existing config, used to indicate that hostname should pass domain control validation (DCV). Can also be used to change validation type, e.g., from 'http' to 'email'. Bundle an existing certificate with another certificate by using the "custom_cert_bundle" field. The bundling process supports combining certificates as long as the following condition is met. One certificate must use the RSA algorithm, and the other must use the ECDSA algorithm.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/custom_hostnames/{custom_hostname_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `custom_hostname_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = edit_custom_hostname(&api)
///     .with_zone_id("zone_id")
///     .with_custom_hostname_id("custom_hostname_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn edit_custom_hostname(api: &ApiClient) -> EditCustomHostnameRequest<'_> {
    EditCustomHostnameRequest::new(api)
}

#[derive(Debug)]
pub struct EditCustomCertificateCustomRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> EditCustomCertificateCustomRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PUT, "zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}")
            .require_path("zone_id")
            .require_path("custom_hostname_id")
            .require_path("certificate_pack_id")
            .require_path("certificate_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_custom_hostname_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("custom_hostname_id", value);
        self
    }
    pub fn with_certificate_pack_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("certificate_pack_id", value);
        self
    }
    pub fn with_certificate_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("certificate_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::tls_certificates_and_hostnames_custom_cert_and_key::TlsCertificatesAndHostnamesCustomCertAndKey,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Replace Custom Certificate and Custom Key In Custom Hostname
///
/// Replace a single custom certificate within a certificate pack that contains two bundled certificates. The replacement must adhere to the following constraints. You can only replace an RSA certificate with another RSA certificate or an ECDSA certificate with another ECDSA certificate.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `custom_hostname_id` (path, required)
/// - `certificate_pack_id` (path, required)
/// - `certificate_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: crate::models::tls_certificates_and_hostnames_custom_cert_and_key::TlsCertificatesAndHostnamesCustomCertAndKey = todo!();
/// let response = edit_custom_certificate_custom(&api)
///     .with_zone_id("zone_id")
///     .with_custom_hostname_id("custom_hostname_id")
///     .with_certificate_pack_id("certificate_pack_id")
///     .with_certificate_id("certificate_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn edit_custom_certificate_custom(api: &ApiClient) -> EditCustomCertificateCustomRequest<'_> {
    EditCustomCertificateCustomRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteSingleCertificateKeyRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> DeleteSingleCertificateKeyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::DELETE, "zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}")
            .require_path("zone_id")
            .require_path("custom_hostname_id")
            .require_path("certificate_pack_id")
            .require_path("certificate_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_custom_hostname_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("custom_hostname_id", value);
        self
    }
    pub fn with_certificate_pack_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("certificate_pack_id", value);
        self
    }
    pub fn with_certificate_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("certificate_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Delete Single Certificate And Key For Custom Hostname
///
/// Delete a single custom certificate from a certificate pack that contains two bundled certificates. Deletion is subject to the following constraints. You cannot delete a certificate if it is the only remaining certificate in the pack. At least one certificate must remain in the pack.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/zones/{zone_id}/custom_hostnames/{custom_hostname_id}/certificate_pack/{certificate_pack_id}/certificates/{certificate_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `custom_hostname_id` (path, required)
/// - `certificate_pack_id` (path, required)
/// - `certificate_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::custom_hostname_for_a_zone };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = delete_single_certificate_key(&api)
///     .with_zone_id("zone_id")
///     .with_custom_hostname_id("custom_hostname_id")
///     .with_certificate_pack_id("certificate_pack_id")
///     .with_certificate_id("certificate_id")
///     .send()
///     .await?;
/// ```
pub fn delete_single_certificate_key(api: &ApiClient) -> DeleteSingleCertificateKeyRequest<'_> {
    DeleteSingleCertificateKeyRequest::new(api)
}
