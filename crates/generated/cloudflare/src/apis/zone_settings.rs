// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::cache_rules_zone_cache_settings_response_single::CacheRulesZoneCacheSettingsResponseSingle;
use crate::models::cache_rules_zone_complex_cache_settings_response_single::CacheRulesZoneComplexCacheSettingsResponseSingle;
use crate::models::speed_api_response_common::SpeedApiResponseCommon;
use crate::models::zones_settings_api_components_schemas_api_response_common::ZonesSettingsApiComponentsSchemasApiResponseCommon;
use crate::models::zones_zone_settings_response_collection::ZonesZoneSettingsResponseCollection;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct GetAllSettingsRequest<'a> {
    builder: ApiRequestBuilder<'a, ZonesZoneSettingsResponseCollection>,
}

impl<'a> GetAllSettingsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/settings")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ZonesZoneSettingsResponseCollection> {
        self.builder.send().await
    }
}
/// Get all zone settings
///
/// Available settings for your user in relation to a zone.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_all_settings(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_all_settings(api: &ApiClient) -> GetAllSettingsRequest<'_> {
    GetAllSettingsRequest::new(api)
}

#[derive(Debug)]
pub struct EditSettingsInfoRequest<'a> {
    builder: ApiRequestBuilder<'a, ZonesZoneSettingsResponseCollection>,
}

impl<'a> EditSettingsInfoRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/settings")
            .require_path("zone_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::zones_multiple_settings::ZonesMultipleSettings,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ZonesZoneSettingsResponseCollection> {
        self.builder.send().await
    }
}
/// Edit multiple zone settings
///
/// Edit settings for a zone.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::zones_multiple_settings::ZonesMultipleSettings = todo!();
/// let response = edit_settings_info(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn edit_settings_info(api: &ApiClient) -> EditSettingsInfoRequest<'_> {
    EditSettingsInfoRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsGetAegisRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneComplexCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsGetAegisRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/settings/aegis")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneComplexCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get aegis setting
///
/// Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/aegis`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cache_settings_get_aegis(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn cache_settings_get_aegis(api: &ApiClient) -> CacheSettingsGetAegisRequest<'_> {
    CacheSettingsGetAegisRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsChangeAegisRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneComplexCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsChangeAegisRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/settings/aegis")
            .require_path("zone_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneComplexCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change aegis setting
///
/// Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/aegis`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = cache_settings_change_aegis(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn cache_settings_change_aegis(api: &ApiClient) -> CacheSettingsChangeAegisRequest<'_> {
    CacheSettingsChangeAegisRequest::new(api)
}

#[derive(Debug)]
pub struct GetFontsSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, SpeedApiResponseCommon>,
}

impl<'a> GetFontsSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/settings/fonts")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<SpeedApiResponseCommon> {
        self.builder.send().await
    }
}
/// Get Cloudflare Fonts setting
///
/// Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
/// boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/fonts`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_fonts_setting(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_fonts_setting(api: &ApiClient) -> GetFontsSettingRequest<'_> {
    GetFontsSettingRequest::new(api)
}

#[derive(Debug)]
pub struct ChangeFontsSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, SpeedApiResponseCommon>,
}

impl<'a> ChangeFontsSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/settings/fonts")
            .require_path("zone_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<SpeedApiResponseCommon> {
        self.builder.send().await
    }
}
/// Change Cloudflare Fonts setting
///
/// Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
/// boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/fonts`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = change_fonts_setting(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn change_fonts_setting(api: &ApiClient) -> ChangeFontsSettingRequest<'_> {
    ChangeFontsSettingRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsGetOriginRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsGetOriginRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/settings/origin_h2_max_streams",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get Origin H2 Max Streams Setting
///
/// Origin H2 Max Streams configures the max number of concurrent requests that Cloudflare will send within the same connection when communicating with the origin server, if the origin supports it. Note that if your origin does not support H2 multiplexing, 5xx errors may be observed, particularly 520s. Also note that the default value is `100` for all plan types except Enterprise where it is `1`. `1` means that H2 multiplexing is disabled.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/origin_h2_max_streams`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cache_settings_get_origin(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn cache_settings_get_origin(api: &ApiClient) -> CacheSettingsGetOriginRequest<'_> {
    CacheSettingsGetOriginRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsChangeOriginRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsChangeOriginRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/settings/origin_h2_max_streams",
        )
        .require_path("zone_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change Origin H2 Max Streams Setting
///
/// Origin H2 Max Streams configures the max number of concurrent requests that Cloudflare will send within the same connection when communicating with the origin server, if the origin supports it. Note that if your origin does not support H2 multiplexing, 5xx errors may be observed, particularly 520s. Also note that the default value is `100` for all plan types except Enterprise where it is `1`. `1` means that H2 multiplexing is disabled.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/origin_h2_max_streams`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = cache_settings_change_origin(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn cache_settings_change_origin(api: &ApiClient) -> CacheSettingsChangeOriginRequest<'_> {
    CacheSettingsChangeOriginRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsGetOriginGetRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsGetOriginGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/settings/origin_max_http_version",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get Origin Max HTTP Version Setting
///
/// Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](<https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/),> for more information.). The default value is "2" for all plan types except Enterprise where it is "1"
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/origin_max_http_version`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cache_settings_get_origin_get(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn cache_settings_get_origin_get(api: &ApiClient) -> CacheSettingsGetOriginGetRequest<'_> {
    CacheSettingsGetOriginGetRequest::new(api)
}

#[derive(Debug)]
pub struct CacheSettingsChangeOriginPatchRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> CacheSettingsChangeOriginPatchRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/settings/origin_max_http_version",
        )
        .require_path("zone_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change Origin Max HTTP Version Setting
///
/// Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](<https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/),> for more information.). The default value is "2" for all plan types except Enterprise where it is "1"
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/origin_max_http_version`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = cache_settings_change_origin_patch(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn cache_settings_change_origin_patch(
    api: &ApiClient,
) -> CacheSettingsChangeOriginPatchRequest<'_> {
    CacheSettingsChangeOriginPatchRequest::new(api)
}

#[derive(Debug)]
pub struct GetSpeedBrainSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, SpeedApiResponseCommon>,
}

impl<'a> GetSpeedBrainSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/settings/speed_brain")
                .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<SpeedApiResponseCommon> {
        self.builder.send().await
    }
}
/// Get Cloudflare Speed Brain setting
///
/// Speed Brain lets compatible browsers speculate on content which can be prefetched or preloaded, making website
/// navigation faster. Refer to the Cloudflare Speed Brain documentation for more information.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/speed_brain`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_speed_brain_setting(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_speed_brain_setting(api: &ApiClient) -> GetSpeedBrainSettingRequest<'_> {
    GetSpeedBrainSettingRequest::new(api)
}

#[derive(Debug)]
pub struct ChangeSpeedBrainSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, SpeedApiResponseCommon>,
}

impl<'a> ChangeSpeedBrainSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/settings/speed_brain")
                .require_path("zone_id")
                .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<SpeedApiResponseCommon> {
        self.builder.send().await
    }
}
/// Change Cloudflare Speed Brain setting
///
/// Speed Brain lets compatible browsers speculate on content which can be prefetched or preloaded, making website
/// navigation faster. Refer to the Cloudflare Speed Brain documentation for more information.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/speed_brain`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = change_speed_brain_setting(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn change_speed_brain_setting(api: &ApiClient) -> ChangeSpeedBrainSettingRequest<'_> {
    ChangeSpeedBrainSettingRequest::new(api)
}

#[derive(Debug)]
pub struct GetSingleSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, ZonesSettingsApiComponentsSchemasApiResponseCommon>,
}

impl<'a> GetSingleSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/settings/{setting_id}")
                .require_path("zone_id")
                .require_path("setting_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_setting_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("setting_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ZonesSettingsApiComponentsSchemasApiResponseCommon> {
        self.builder.send().await
    }
}
/// Get zone setting
///
/// Fetch a single zone setting by name
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/{setting_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `setting_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_single_setting(&api)
///     .with_zone_id("zone_id")
///     .with_setting_id("setting_id")
///     .send()
///     .await?;
/// ```
pub fn get_single_setting(api: &ApiClient) -> GetSingleSettingRequest<'_> {
    GetSingleSettingRequest::new(api)
}

#[derive(Debug)]
pub struct EditSingleSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, ZonesSettingsApiComponentsSchemasApiResponseCommon>,
}

impl<'a> EditSingleSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/settings/{setting_id}")
                .require_path("zone_id")
                .require_path("setting_id")
                .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_setting_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("setting_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::zones_zone_settings_single_request::ZonesZoneSettingsSingleRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ZonesSettingsApiComponentsSchemasApiResponseCommon> {
        self.builder.send().await
    }
}
/// Edit zone setting
///
/// Updates a single zone setting by the identifier
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/{setting_id}`
///
/// **Parameters**
/// - `zone_id` (path, required)
/// - `setting_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_settings };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::zones_zone_settings_single_request::ZonesZoneSettingsSingleRequest = todo!();
/// let response = edit_single_setting(&api)
///     .with_zone_id("zone_id")
///     .with_setting_id("setting_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn edit_single_setting(api: &ApiClient) -> EditSingleSettingRequest<'_> {
    EditSingleSettingRequest::new(api)
}
