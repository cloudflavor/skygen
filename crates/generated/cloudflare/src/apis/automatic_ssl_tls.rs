// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::cache_automatic_upgrader_response::CacheAutomaticUpgraderResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct DetectorAutomaticModeGetRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheAutomaticUpgraderResponse>,
}

impl<'a> DetectorAutomaticModeGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/settings/ssl_automatic_mode",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheAutomaticUpgraderResponse> {
        self.builder.send().await
    }
}
/// Get Automatic SSL/TLS enrollment status for the given zone
///
/// If the system is enabled, the response will include next_scheduled_scan, representing the next time this zone will be scanned and the zone's ssl/tls encryption mode is potentially upgraded by the system. If the system is disabled, next_scheduled_scan will not be present in the response body.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/settings/ssl_automatic_mode`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::automatic_ssl_tls };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = detector_automatic_mode_get(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn detector_automatic_mode_get(api: &ApiClient) -> DetectorAutomaticModeGetRequest<'_> {
    DetectorAutomaticModeGetRequest::new(api)
}

#[derive(Debug)]
pub struct DetectorAutomaticModePatchRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheAutomaticUpgraderResponse>,
}

impl<'a> DetectorAutomaticModePatchRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/settings/ssl_automatic_mode",
        )
        .require_path("zone_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::cache_schemas_patch::CacheSchemasPatch,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheAutomaticUpgraderResponse> {
        self.builder.send().await
    }
}
/// Patch Automatic SSL/TLS Enrollment status for given zone
///
/// The automatic system is enabled when this endpoint is hit with value in the request body is set to "auto", and disabled when the request body value is set to "custom".
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/settings/ssl_automatic_mode`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::automatic_ssl_tls };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: crate::models::cache_schemas_patch::CacheSchemasPatch = todo!();
/// let response = detector_automatic_mode_patch(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detector_automatic_mode_patch(api: &ApiClient) -> DetectorAutomaticModePatchRequest<'_> {
    DetectorAutomaticModePatchRequest::new(api)
}
