// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::workers_kv_api_response_collection::WorkersKvApiResponseCollection;
use crate::models::workers_kv_api_response_common::WorkersKvApiResponseCommon;
use crate::models::workers_kv_api_response_common_no_result::WorkersKvApiResponseCommonNoResult;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListNamespacesRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCollection>,
}

impl<'a> ListNamespacesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/storage/kv/namespaces",
        )
        .require_path("account_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_order(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order", value);
        self
    }
    pub fn with_direction(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("direction", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCollection> {
        self.builder.send().await
    }
}
/// List Namespaces
///
/// Returns the namespaces owned by an account.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `page` (query,optional)
/// - `per_page` (query,optional)
/// - `order` (query,optional)
/// - `direction` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_namespaces(&api)
///     .with_account_id("account_id")
///     .with_page("page")
///     .with_per_page("per_page")
///     .with_order("order")
///     .with_direction("direction")
///     .send()
///     .await?;
/// ```
pub fn list_namespaces(api: &ApiClient) -> ListNamespacesRequest<'_> {
    ListNamespacesRequest::new(api)
}

#[derive(Debug)]
pub struct CreateNamespaceRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommon>,
}

impl<'a> CreateNamespaceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "accounts/{account_id}/storage/kv/namespaces",
        )
        .require_path("account_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::workers_kv_create_rename_namespace_body::WorkersKvCreateRenameNamespaceBody,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommon> {
        self.builder.send().await
    }
}
/// Create a Namespace
///
/// Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces`
///
/// **Parameters**
/// - `account_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::workers_kv_create_rename_namespace_body::WorkersKvCreateRenameNamespaceBody = todo!();
/// let response = create_namespace(&api)
///     .with_account_id("account_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_namespace(api: &ApiClient) -> CreateNamespaceRequest<'_> {
    CreateNamespaceRequest::new(api)
}

#[derive(Debug)]
pub struct GetNamespaceRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommon>,
}

impl<'a> GetNamespaceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}",
        )
        .require_path("account_id")
        .require_path("namespace_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommon> {
        self.builder.send().await
    }
}
/// Get a Namespace
///
/// Get the namespace corresponding to the given ID.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_namespace(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .send()
///     .await?;
/// ```
pub fn get_namespace(api: &ApiClient) -> GetNamespaceRequest<'_> {
    GetNamespaceRequest::new(api)
}

#[derive(Debug)]
pub struct RenameNamespaceRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommon>,
}

impl<'a> RenameNamespaceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::workers_kv_create_rename_namespace_body::WorkersKvCreateRenameNamespaceBody,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommon> {
        self.builder.send().await
    }
}
/// Rename a Namespace
///
/// Modifies a namespace's title.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::workers_kv_create_rename_namespace_body::WorkersKvCreateRenameNamespaceBody = todo!();
/// let response = rename_namespace(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn rename_namespace(api: &ApiClient) -> RenameNamespaceRequest<'_> {
    RenameNamespaceRequest::new(api)
}

#[derive(Debug)]
pub struct RemoveNamespaceRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> RemoveNamespaceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}",
        )
        .require_path("account_id")
        .require_path("namespace_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Remove a Namespace
///
/// Deletes the namespace corresponding to the given ID.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = remove_namespace(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .send()
///     .await?;
/// ```
pub fn remove_namespace(api: &ApiClient) -> RemoveNamespaceRequest<'_> {
    RemoveNamespaceRequest::new(api)
}

#[derive(Debug)]
pub struct WriteMultipleKeyValueRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> WriteMultipleKeyValueRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::workers_kv_bulk_write::WorkersKvBulkWrite,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Write multiple key-value pairs
///
/// Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::workers_kv_bulk_write::WorkersKvBulkWrite = todo!();
/// let response = write_multiple_key_value(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn write_multiple_key_value(api: &ApiClient) -> WriteMultipleKeyValueRequest<'_> {
    WriteMultipleKeyValueRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteMultipleKeyValueRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> DeleteMultipleKeyValueRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::workers_kv_bulk_delete::WorkersKvBulkDelete,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Delete multiple key-value pairs
///
/// Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::workers_kv_bulk_delete::WorkersKvBulkDelete = todo!();
/// let response = delete_multiple_key_value(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn delete_multiple_key_value(api: &ApiClient) -> DeleteMultipleKeyValueRequest<'_> {
    DeleteMultipleKeyValueRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteMultipleKeyValuePostRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> DeleteMultipleKeyValuePostRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk/delete",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::workers_kv_bulk_delete::WorkersKvBulkDelete,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Delete multiple key-value pairs
///
/// Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk/delete`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::workers_kv_bulk_delete::WorkersKvBulkDelete = todo!();
/// let response = delete_multiple_key_value_post(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn delete_multiple_key_value_post(api: &ApiClient) -> DeleteMultipleKeyValuePostRequest<'_> {
    DeleteMultipleKeyValuePostRequest::new(api)
}

#[derive(Debug)]
pub struct GetMultipleKeyValueRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> GetMultipleKeyValueRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk/get",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Get multiple key-value pairs
///
/// Get multiple KV pairs from the namespace. Body should contain keys to retrieve at most 100. Keys must contain text-based values. If value is json, it can be requested to return in JSON, instead of string. Metadata can be return if withMetadata is true.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/bulk/get`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = get_multiple_key_value(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn get_multiple_key_value(api: &ApiClient) -> GetMultipleKeyValueRequest<'_> {
    GetMultipleKeyValueRequest::new(api)
}

#[derive(Debug)]
pub struct ListNamespaceSKeysRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommon>,
}

impl<'a> ListNamespaceSKeysRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/keys",
        )
        .require_path("account_id")
        .require_path("namespace_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_limit(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("limit", value);
        self
    }
    pub fn with_prefix(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("prefix", value);
        self
    }
    pub fn with_cursor(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("cursor", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommon> {
        self.builder.send().await
    }
}
/// List a Namespace's Keys
///
/// Lists a namespace's keys.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/keys`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
/// - `limit` (query,optional)
/// - `prefix` (query,optional)
/// - `cursor` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_namespace_s_keys(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_limit("limit")
///     .with_prefix("prefix")
///     .with_cursor("cursor")
///     .send()
///     .await?;
/// ```
pub fn list_namespace_s_keys(api: &ApiClient) -> ListNamespaceSKeysRequest<'_> {
    ListNamespaceSKeysRequest::new(api)
}

#[derive(Debug)]
pub struct ReadMetadataKeyRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommon>,
}

impl<'a> ReadMetadataKeyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/metadata/{key_name}",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_path("key_name");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_key_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("key_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommon> {
        self.builder.send().await
    }
}
/// Read the metadata for a key
///
/// Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/metadata/{key_name}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
/// - `key_name` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = read_metadata_key(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_key_name("key_name")
///     .send()
///     .await?;
/// ```
pub fn read_metadata_key(api: &ApiClient) -> ReadMetadataKeyRequest<'_> {
    ReadMetadataKeyRequest::new(api)
}

#[derive(Debug)]
pub struct ReadKeyValuePairRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ReadKeyValuePairRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_path("key_name");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_key_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("key_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Read key-value pair
///
/// Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
/// - `key_name` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = read_key_value_pair(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_key_name("key_name")
///     .send()
///     .await?;
/// ```
pub fn read_key_value_pair(api: &ApiClient) -> ReadKeyValuePairRequest<'_> {
    ReadKeyValuePairRequest::new(api)
}

#[derive(Debug)]
pub struct WriteKeyValuePairRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> WriteKeyValuePairRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_path("key_name");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_key_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("key_name", value);
        self
    }
    pub fn with_expiration(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("expiration", value);
        self
    }
    pub fn with_expiration_ttl(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("expiration_ttl", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Write key-value pair with optional metadata
///
/// Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored. If JSON metadata to be associated with the key/value pair is needed, use `multipart/form-data` content type for your PUT request (see dropdown below in `REQUEST BODY SCHEMA`). Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
/// - `key_name` (path, required)
/// - `expiration` (query,optional)
/// - `expiration_ttl` (query,optional)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = write_key_value_pair(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_key_name("key_name")
///     .with_expiration("expiration")
///     .with_expiration_ttl("expiration_ttl")
///     .send()
///     .await?;
/// ```
pub fn write_key_value_pair(api: &ApiClient) -> WriteKeyValuePairRequest<'_> {
    WriteKeyValuePairRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteKeyValuePairRequest<'a> {
    builder: ApiRequestBuilder<'a, WorkersKvApiResponseCommonNoResult>,
}

impl<'a> DeleteKeyValuePairRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}",
        )
        .require_path("account_id")
        .require_path("namespace_id")
        .require_path("key_name");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_namespace_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("namespace_id", value);
        self
    }
    pub fn with_key_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("key_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<WorkersKvApiResponseCommonNoResult> {
        self.builder.send().await
    }
}
/// Delete key-value pair
///
/// Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/accounts/{account_id}/storage/kv/namespaces/{namespace_id}/values/{key_name}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `namespace_id` (path, required)
/// - `key_name` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::workers_kv_namespace };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_key_value_pair(&api)
///     .with_account_id("account_id")
///     .with_namespace_id("namespace_id")
///     .with_key_name("key_name")
///     .send()
///     .await?;
/// ```
pub fn delete_key_value_pair(api: &ApiClient) -> DeleteKeyValuePairRequest<'_> {
    DeleteKeyValuePairRequest::new(api)
}
