// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::addressing_response_collection_bgp::AddressingResponseCollectionBgp;
use crate::models::addressing_single_response_bgp::AddressingSingleResponseBgp;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListBgpPrefixesRequest<'a> {
    builder: ApiRequestBuilder<'a, AddressingResponseCollectionBgp>,
}

impl<'a> ListBgpPrefixesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes",
        )
        .require_path("account_id")
        .require_path("prefix_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("prefix_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AddressingResponseCollectionBgp> {
        self.builder.send().await
    }
}
/// List BGP Prefixes
///
/// List all BGP Prefixes within the specified IP Prefix. BGP Prefixes are used to control which specific subnets are advertised to the Internet. It is possible to advertise subnets more specific than an IP Prefix by creating more specific BGP Prefixes.
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `prefix_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::ip_address_management_bgp_prefixes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_bgp_prefixes(&api)
///     .with_account_id("account_id")
///     .with_prefix_id("prefix_id")
///     .send()
///     .await?;
/// ```
pub fn list_bgp_prefixes(api: &ApiClient) -> ListBgpPrefixesRequest<'_> {
    ListBgpPrefixesRequest::new(api)
}

#[derive(Debug)]
pub struct CreateBgpPrefixRequest<'a> {
    builder: ApiRequestBuilder<'a, AddressingSingleResponseBgp>,
}

impl<'a> CreateBgpPrefixRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes",
        )
        .require_path("account_id")
        .require_path("prefix_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("prefix_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::addressing_bgp_prefix_create::AddressingBgpPrefixCreate,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AddressingSingleResponseBgp> {
        self.builder.send().await
    }
}
/// Create BGP Prefix
///
/// Create a BGP prefix, controlling the BGP advertisement status of a specific subnet. When created, BGP prefixes are initially withdrawn, and can be advertised with the Update BGP Prefix API.
///
/// **HTTP Method:** `POST`
/// **Path:** `/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `prefix_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::ip_address_management_bgp_prefixes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::addressing_bgp_prefix_create::AddressingBgpPrefixCreate = todo!();
/// let response = create_bgp_prefix(&api)
///     .with_account_id("account_id")
///     .with_prefix_id("prefix_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_bgp_prefix(api: &ApiClient) -> CreateBgpPrefixRequest<'_> {
    CreateBgpPrefixRequest::new(api)
}

#[derive(Debug)]
pub struct FetchBgpPrefixRequest<'a> {
    builder: ApiRequestBuilder<'a, AddressingSingleResponseBgp>,
}

impl<'a> FetchBgpPrefixRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}",
        )
        .require_path("account_id")
        .require_path("prefix_id")
        .require_path("bgp_prefix_id");

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("prefix_id", value);
        self
    }
    pub fn with_bgp_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("bgp_prefix_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AddressingSingleResponseBgp> {
        self.builder.send().await
    }
}
/// Fetch BGP Prefix
///
/// Retrieve a single BGP Prefix according to its identifier
///
/// **HTTP Method:** `GET`
/// **Path:** `/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `prefix_id` (path, required)
/// - `bgp_prefix_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::ip_address_management_bgp_prefixes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = fetch_bgp_prefix(&api)
///     .with_account_id("account_id")
///     .with_prefix_id("prefix_id")
///     .with_bgp_prefix_id("bgp_prefix_id")
///     .send()
///     .await?;
/// ```
pub fn fetch_bgp_prefix(api: &ApiClient) -> FetchBgpPrefixRequest<'_> {
    FetchBgpPrefixRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateBgpPrefixRequest<'a> {
    builder: ApiRequestBuilder<'a, AddressingSingleResponseBgp>,
}

impl<'a> UpdateBgpPrefixRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}",
        )
        .require_path("account_id")
        .require_path("prefix_id")
        .require_path("bgp_prefix_id")
        .require_body();

        Self { builder }
    }
    pub fn with_account_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("account_id", value);
        self
    }
    pub fn with_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("prefix_id", value);
        self
    }
    pub fn with_bgp_prefix_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("bgp_prefix_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::addressing_bgp_prefix_update_advertisement::AddressingBgpPrefixUpdateAdvertisement,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AddressingSingleResponseBgp> {
        self.builder.send().await
    }
}
/// Update BGP Prefix
///
/// Update the properties of a BGP Prefix, such as the on demand advertisement status (advertised or withdrawn).
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/accounts/{account_id}/addressing/prefixes/{prefix_id}/bgp/prefixes/{bgp_prefix_id}`
///
/// **Parameters**
/// - `account_id` (path, required)
/// - `prefix_id` (path, required)
/// - `bgp_prefix_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::ip_address_management_bgp_prefixes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::addressing_bgp_prefix_update_advertisement::AddressingBgpPrefixUpdateAdvertisement = todo!();
/// let response = update_bgp_prefix(&api)
///     .with_account_id("account_id")
///     .with_prefix_id("prefix_id")
///     .with_bgp_prefix_id("bgp_prefix_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_bgp_prefix(api: &ApiClient) -> UpdateBgpPrefixRequest<'_> {
    UpdateBgpPrefixRequest::new(api)
}
