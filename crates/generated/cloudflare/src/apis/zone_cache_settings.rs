// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::cache_rules_api_response_common::CacheRulesApiResponseCommon;
use crate::models::cache_rules_zone_cache_settings_delete_response_single::CacheRulesZoneCacheSettingsDeleteResponseSingle;
use crate::models::cache_rules_zone_cache_settings_response_single::CacheRulesZoneCacheSettingsResponseSingle;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct GetCacheReserveSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> GetCacheReserveSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/cache/cache_reserve")
                .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get Cache Reserve setting
///
/// Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](<https://developers.cloudflare.com/cache/about/cache-reserve)> for more information.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/cache/cache_reserve`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_cache_reserve_setting(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_cache_reserve_setting(api: &ApiClient) -> GetCacheReserveSettingRequest<'_> {
    GetCacheReserveSettingRequest::new(api)
}

#[derive(Debug)]
pub struct ChangeCacheReserveSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> ChangeCacheReserveSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/cache/cache_reserve")
                .require_path("zone_id")
                .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change Cache Reserve setting
///
/// Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](<https://developers.cloudflare.com/cache/about/cache-reserve)> for more information.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/cache/cache_reserve`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = change_cache_reserve_setting(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn change_cache_reserve_setting(api: &ApiClient) -> ChangeCacheReserveSettingRequest<'_> {
    ChangeCacheReserveSettingRequest::new(api)
}

#[derive(Debug)]
pub struct GetCacheReserveClearRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesApiResponseCommon>,
}

impl<'a> GetCacheReserveClearRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/cache/cache_reserve_clear",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesApiResponseCommon> {
        self.builder.send().await
    }
}
/// Get Cache Reserve Clear
///
/// You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/cache/cache_reserve_clear`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_cache_reserve_clear(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_cache_reserve_clear(api: &ApiClient) -> GetCacheReserveClearRequest<'_> {
    GetCacheReserveClearRequest::new(api)
}

#[derive(Debug)]
pub struct StartCacheReserveClearRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesApiResponseCommon>,
}

impl<'a> StartCacheReserveClearRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "zones/{zone_id}/cache/cache_reserve_clear",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesApiResponseCommon> {
        self.builder.send().await
    }
}
/// Start Cache Reserve Clear
///
/// You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
///
/// **HTTP Method:** `POST`
/// **Path:** `/zones/{zone_id}/cache/cache_reserve_clear`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = start_cache_reserve_clear(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn start_cache_reserve_clear(api: &ApiClient) -> StartCacheReserveClearRequest<'_> {
    StartCacheReserveClearRequest::new(api)
}

#[derive(Debug)]
pub struct GetRegionalTieredCacheRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> GetRegionalTieredCacheRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "zones/{zone_id}/cache/regional_tiered_cache",
        )
        .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get Regional Tiered Cache setting
///
/// Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/cache/regional_tiered_cache`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_regional_tiered_cache(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_regional_tiered_cache(api: &ApiClient) -> GetRegionalTieredCacheRequest<'_> {
    GetRegionalTieredCacheRequest::new(api)
}

#[derive(Debug)]
pub struct ChangeRegionalTieredCacheRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> ChangeRegionalTieredCacheRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "zones/{zone_id}/cache/regional_tiered_cache",
        )
        .require_path("zone_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change Regional Tiered Cache setting
///
/// Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/cache/regional_tiered_cache`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = change_regional_tiered_cache(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn change_regional_tiered_cache(api: &ApiClient) -> ChangeRegionalTieredCacheRequest<'_> {
    ChangeRegionalTieredCacheRequest::new(api)
}

#[derive(Debug)]
pub struct GetVariantsSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> GetVariantsSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "zones/{zone_id}/cache/variants")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Get variants setting
///
/// Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
///
/// **HTTP Method:** `GET`
/// **Path:** `/zones/{zone_id}/cache/variants`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = get_variants_setting(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn get_variants_setting(api: &ApiClient) -> GetVariantsSettingRequest<'_> {
    GetVariantsSettingRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteVariantsSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsDeleteResponseSingle>,
}

impl<'a> DeleteVariantsSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::DELETE, "zones/{zone_id}/cache/variants")
            .require_path("zone_id");

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsDeleteResponseSingle> {
        self.builder.send().await
    }
}
/// Delete variants setting
///
/// Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/zones/{zone_id}/cache/variants`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// let response = delete_variants_setting(&api)
///     .with_zone_id("zone_id")
///     .send()
///     .await?;
/// ```
pub fn delete_variants_setting(api: &ApiClient) -> DeleteVariantsSettingRequest<'_> {
    DeleteVariantsSettingRequest::new(api)
}

#[derive(Debug)]
pub struct ChangeVariantsSettingRequest<'a> {
    builder: ApiRequestBuilder<'a, CacheRulesZoneCacheSettingsResponseSingle>,
}

impl<'a> ChangeVariantsSettingRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PATCH, "zones/{zone_id}/cache/variants")
            .require_path("zone_id")
            .require_body();

        Self { builder }
    }
    pub fn with_zone_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<CacheRulesZoneCacheSettingsResponseSingle> {
        self.builder.send().await
    }
}
/// Change variants setting
///
/// Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/zones/{zone_id}/cache/variants`
///
/// **Parameters**
/// - `zone_id` (path, required)
///
/// # Example
/// ```no_run
/// use cloudflare::{ ApiClient, apis::zone_cache_settings };
///
/// let api = ApiClient::builder().build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = change_variants_setting(&api)
///     .with_zone_id("zone_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn change_variants_setting(api: &ApiClient) -> ChangeVariantsSettingRequest<'_> {
    ChangeVariantsSettingRequest::new(api)
}
