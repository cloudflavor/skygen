// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;
use crate::models::scaleway_interlink_v1beta1_link::ScalewayInterlinkV1beta1Link;
use crate::models::scaleway_interlink_v1beta1_list_links_response::ScalewayInterlinkV1beta1ListLinksResponse;

#[derive(Debug)]
pub struct ListLinksRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1ListLinksResponse>,
}

impl<'a> ListLinksRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "interlink/v1beta1/regions/{region}/links")
            .require_path("region");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub fn with_project_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project_id", value);
        self
    }
    pub fn with_organization_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_tags(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tags", value);
        self
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_bgp_v4_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("bgp_v4_status", value);
        self
    }
    pub fn with_bgp_v6_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("bgp_v6_status", value);
        self
    }
    pub fn with_pop_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("pop_id", value);
        self
    }
    pub fn with_bandwidth_mbps(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("bandwidth_mbps", value);
        self
    }
    pub fn with_partner_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("partner_id", value);
        self
    }
    pub fn with_vpc_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("vpc_id", value);
        self
    }
    pub fn with_routing_policy_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("routing_policy_id", value);
        self
    }
    pub fn with_pairing_key(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("pairing_key", value);
        self
    }
    pub fn with_kind(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("kind", value);
        self
    }
    pub fn with_connection_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("connection_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1ListLinksResponse> {
        self.builder.send().await
    }
}
/// List links
///
/// List all your links (InterLink connections). A number of filters are available, including Project ID, name, tags and status.
///
/// **HTTP Method:** `GET`
/// **Path:** `/interlink/v1beta1/regions/{region}/links`
///
/// **Parameters**
/// - `region` (path, required)
/// - `order_by` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
/// - `project_id` (query,optional)
/// - `organization_id` (query,optional)
/// - `name` (query,optional)
/// - `tags` (query,optional)
/// - `status` (query,optional)
/// - `bgp_v4_status` (query,optional)
/// - `bgp_v6_status` (query,optional)
/// - `pop_id` (query,optional)
/// - `bandwidth_mbps` (query,optional)
/// - `partner_id` (query,optional)
/// - `vpc_id` (query,optional)
/// - `routing_policy_id` (query,optional)
/// - `pairing_key` (query,optional)
/// - `kind` (query,optional)
/// - `connection_id` (query,optional)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_links(&api)
///     .with_region("region")
///     .with_order_by("order_by")
///     .with_page("page")
///     .with_page_size("page_size")
///     .with_project_id("project_id")
///     .with_organization_id("organization_id")
///     .with_name("name")
///     .with_tags("tags")
///     .with_status("status")
///     .with_bgp_v4_status("bgp_v4_status")
///     .with_bgp_v6_status("bgp_v6_status")
///     .with_pop_id("pop_id")
///     .with_bandwidth_mbps("bandwidth_mbps")
///     .with_partner_id("partner_id")
///     .with_vpc_id("vpc_id")
///     .with_routing_policy_id("routing_policy_id")
///     .with_pairing_key("pairing_key")
///     .with_kind("kind")
///     .with_connection_id("connection_id")
///     .send()
///     .await?;
/// ```
pub fn list_links(api: &ApiClient) -> ListLinksRequest<'_> {
    ListLinksRequest::new(api)
}

#[derive(Debug)]
pub struct CreateLinkRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> CreateLinkRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links")
            .require_path("region")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Create a link
///
/// Create a link (InterLink session / logical InterLink resource) in a given PoP, specifying its various configuration details. Links can either be hosted (facilitated by partners' shared physical connections) or self-hosted (for users who have purchased a dedicated physical connection).
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links`
///
/// **Parameters**
/// - `region` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_link(&api)
///     .with_region("region")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_link(api: &ApiClient) -> CreateLinkRequest<'_> {
    CreateLinkRequest::new(api)
}

#[derive(Debug)]
pub struct LinkRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> LinkRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "interlink/v1beta1/regions/{region}/links/{link_id}")
            .require_path("region")
            .require_path("link_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Get a link
///
/// Get a link (InterLink session / logical InterLink resource) for the given link ID. The response object includes information about the link's various configuration details.
///
/// **HTTP Method:** `GET`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = link(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .send()
///     .await?;
/// ```
pub fn link(api: &ApiClient) -> LinkRequest<'_> {
    LinkRequest::new(api)
}

#[derive(Debug)]
pub struct LinkDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> LinkDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::DELETE, "interlink/v1beta1/regions/{region}/links/{link_id}")
            .require_path("region")
            .require_path("link_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Delete a link
///
/// Delete an existing link, specified by its link ID. Note that as well as deleting the link here on the Scaleway side, it is also necessary to request deletion from the partner on their side. Only when this action has been carried out on both sides will the resource be completely deleted.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = link_delete(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .send()
///     .await?;
/// ```
pub fn link_delete(api: &ApiClient) -> LinkDeleteRequest<'_> {
    LinkDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateLinkRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> UpdateLinkRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PATCH, "interlink/v1beta1/regions/{region}/links/{link_id}")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Update a link
///
/// Update an existing link, specified by its link ID. Only its name and tags can be updated.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_link(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_link(api: &ApiClient) -> UpdateLinkRequest<'_> {
    UpdateLinkRequest::new(api)
}

#[derive(Debug)]
pub struct AttachRoutingPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> AttachRoutingPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/attach-routing-policy")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Attach a routing policy
///
/// Attach a routing policy to an existing link. As all routes across the link are blocked by default, you must attach a routing policy to set IP prefix filters for allowed routes, facilitating traffic flow.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/attach-routing-policy`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = attach_routing_policy(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn attach_routing_policy(api: &ApiClient) -> AttachRoutingPolicyRequest<'_> {
    AttachRoutingPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct AttachVpcRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> AttachVpcRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/attach-vpc")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Attach a VPC
///
/// Attach a VPC to an existing link. This facilitates communication between the resources in your Scaleway VPC, and your on-premises infrastructure.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/attach-vpc`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = attach_vpc(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn attach_vpc(api: &ApiClient) -> AttachVpcRequest<'_> {
    AttachVpcRequest::new(api)
}

#[derive(Debug)]
pub struct DetachRoutingPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> DetachRoutingPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/detach-routing-policy")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Detach a routing policy
///
/// Detach a routing policy from an existing link. Without a routing policy, all routes across the link are blocked by default.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/detach-routing-policy`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = detach_routing_policy(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detach_routing_policy(api: &ApiClient) -> DetachRoutingPolicyRequest<'_> {
    DetachRoutingPolicyRequest::new(api)
}

#[derive(Debug)]
pub struct DetachVpcRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> DetachVpcRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/detach-vpc")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Detach a VPC
///
/// Detach a VPC from an existing link.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/detach-vpc`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = detach_vpc(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detach_vpc(api: &ApiClient) -> DetachVpcRequest<'_> {
    DetachVpcRequest::new(api)
}

#[derive(Debug)]
pub struct DisableRoutePropagationRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> DisableRoutePropagationRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/disable-route-propagation")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Disable route propagation
///
/// Prevent any prefixes from being announced in the BGP session. Traffic will not be able to flow over the InterLink until route propagation is re-enabled.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/disable-route-propagation`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = disable_route_propagation(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn disable_route_propagation(api: &ApiClient) -> DisableRoutePropagationRequest<'_> {
    DisableRoutePropagationRequest::new(api)
}

#[derive(Debug)]
pub struct EnableRoutePropagationRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> EnableRoutePropagationRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/enable-route-propagation")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Enable route propagation
///
/// Enable all allowed prefixes (defined in a routing policy) to be announced in the BGP session. This allows traffic to flow between the attached VPC and the on-premises infrastructure along the announced routes. Note that by default, even when route propagation is enabled, all routes are blocked. It is essential to attach a routing policy to define the ranges of routes to announce.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/enable-route-propagation`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = enable_route_propagation(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn enable_route_propagation(api: &ApiClient) -> EnableRoutePropagationRequest<'_> {
    EnableRoutePropagationRequest::new(api)
}

#[derive(Debug)]
pub struct SetRoutingPolicyRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInterlinkV1beta1Link>,
}

impl<'a> SetRoutingPolicyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "interlink/v1beta1/regions/{region}/links/{link_id}/set-routing-policy")
            .require_path("region")
            .require_path("link_id")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_link_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("link_id", value);
        self
    }
    pub fn with_body(mut self, body: std::collections::BTreeMap<String, serde_json::Value>) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInterlinkV1beta1Link> {
        self.builder.send().await
    }
}
/// Set a routing policy
///
/// Replace a routing policy from an existing link. This is useful when route propagation is enabled because it changes the routing policy "in place", without blocking all routes like a attach / detach would do.
///
/// **HTTP Method:** `POST`
/// **Path:** `/interlink/v1beta1/regions/{region}/links/{link_id}/set-routing-policy`
///
/// **Parameters**
/// - `region` (path, required)
/// - `link_id` (path, required)
///
/// # Example
/// ```no_run
/// use interlink::{ ApiClient, apis::links };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = set_routing_policy(&api)
///     .with_region("region")
///     .with_link_id("link_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_routing_policy(api: &ApiClient) -> SetRoutingPolicyRequest<'_> {
    SetRoutingPolicyRequest::new(api)
}


