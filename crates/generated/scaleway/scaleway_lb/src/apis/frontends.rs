// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_lb_v1_frontend::ScalewayLbV1Frontend;
use crate::models::scaleway_lb_v1_list_frontends_response::ScalewayLbV1ListFrontendsResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct FrontendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Frontend>,
}

impl<'a> FrontendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "lb/v1/zones/{zone}/frontends/{frontend_id}",
        )
        .require_path("zone")
        .require_path("frontend_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_frontend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("frontend_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Frontend> {
        self.builder.send().await
    }
}
/// Get a frontend
///
/// Get the full details of a given frontend, specified by its frontend ID. The response contains the frontend's full configuration parameters including the backend it is attached to, the port it listens on, and any certificates it has.
///
/// **HTTP Method:** `GET`
/// **Path:** `/lb/v1/zones/{zone}/frontends/{frontend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `frontend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::frontends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = frontend(&api)
///     .with_zone("zone")
///     .with_frontend_id("frontend_id")
///     .send()
///     .await?;
/// ```
pub fn frontend(api: &ApiClient) -> FrontendRequest<'_> {
    FrontendRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateFrontendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Frontend>,
}

impl<'a> UpdateFrontendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "lb/v1/zones/{zone}/frontends/{frontend_id}",
        )
        .require_path("zone")
        .require_path("frontend_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_frontend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("frontend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Frontend> {
        self.builder.send().await
    }
}
/// Update a frontend
///
/// Update a given frontend, specified by its frontend ID. You can update configuration parameters including its name and the port it listens on. Note that the request type is PUT and not PATCH. You must set all parameters.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/lb/v1/zones/{zone}/frontends/{frontend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `frontend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::frontends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_frontend(&api)
///     .with_zone("zone")
///     .with_frontend_id("frontend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_frontend(api: &ApiClient) -> UpdateFrontendRequest<'_> {
    UpdateFrontendRequest::new(api)
}

#[derive(Debug)]
pub struct FrontendDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> FrontendDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "lb/v1/zones/{zone}/frontends/{frontend_id}",
        )
        .require_path("zone")
        .require_path("frontend_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_frontend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("frontend_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Delete a frontend
///
/// Delete a given frontend, specified by its frontend ID. This action is irreversible and cannot be undone.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/lb/v1/zones/{zone}/frontends/{frontend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `frontend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::frontends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = frontend_delete(&api)
///     .with_zone("zone")
///     .with_frontend_id("frontend_id")
///     .send()
///     .await?;
/// ```
pub fn frontend_delete(api: &ApiClient) -> FrontendDeleteRequest<'_> {
    FrontendDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct ListFrontendsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1ListFrontendsResponse>,
}

impl<'a> ListFrontendsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "lb/v1/zones/{zone}/lbs/{lb_id}/frontends")
                .require_path("zone")
                .require_path("lb_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_lb_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("lb_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1ListFrontendsResponse> {
        self.builder.send().await
    }
}
/// List frontends of a given Load Balancer
///
/// List all the frontends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each frontend. The response is an array of frontend objects, containing full details of each one including the port they listen on and the backend they are attached to.
///
/// **HTTP Method:** `GET`
/// **Path:** `/lb/v1/zones/{zone}/lbs/{lb_id}/frontends`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `lb_id` (path, required)
/// - `name` (query,optional)
/// - `order_by` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::frontends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_frontends(&api)
///     .with_zone("zone")
///     .with_lb_id("lb_id")
///     .with_name("name")
///     .with_order_by("order_by")
///     .with_page("page")
///     .with_page_size("page_size")
///     .send()
///     .await?;
/// ```
pub fn list_frontends(api: &ApiClient) -> ListFrontendsRequest<'_> {
    ListFrontendsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateFrontendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Frontend>,
}

impl<'a> CreateFrontendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "lb/v1/zones/{zone}/lbs/{lb_id}/frontends",
        )
        .require_path("zone")
        .require_path("lb_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_lb_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("lb_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Frontend> {
        self.builder.send().await
    }
}
/// Create a frontend in a given Load Balancer
///
/// Create a new frontend for a given Load Balancer, specifying its configuration including the port it should listen on and the backend to attach it to.
///
/// **HTTP Method:** `POST`
/// **Path:** `/lb/v1/zones/{zone}/lbs/{lb_id}/frontends`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `lb_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::frontends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_frontend(&api)
///     .with_zone("zone")
///     .with_lb_id("lb_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_frontend(api: &ApiClient) -> CreateFrontendRequest<'_> {
    CreateFrontendRequest::new(api)
}
