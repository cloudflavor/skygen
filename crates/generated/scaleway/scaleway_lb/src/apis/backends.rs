// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_lb_v1_backend::ScalewayLbV1Backend;
use crate::models::scaleway_lb_v1_health_check::ScalewayLbV1HealthCheck;
use crate::models::scaleway_lb_v1_list_backend_stats_response::ScalewayLbV1ListBackendStatsResponse;
use crate::models::scaleway_lb_v1_list_backends_response::ScalewayLbV1ListBackendsResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct BackendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> BackendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "lb/v1/zones/{zone}/backends/{backend_id}")
                .require_path("zone")
                .require_path("backend_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Get a backend of a given Load Balancer
///
/// Get the full details of a given backend, specified by its backend ID. The response contains the backend's full configuration parameters including protocol, port and forwarding algorithm.
///
/// **HTTP Method:** `GET`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = backend(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .send()
///     .await?;
/// ```
pub fn backend(api: &ApiClient) -> BackendRequest<'_> {
    BackendRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateBackendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> UpdateBackendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PUT, "lb/v1/zones/{zone}/backends/{backend_id}")
                .require_path("zone")
                .require_path("backend_id")
                .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Update a backend of a given Load Balancer
///
/// Update a backend of a given Load Balancer, specified by its backend ID. Note that the request type is PUT and not PATCH. You must set all parameters.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_backend(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_backend(api: &ApiClient) -> UpdateBackendRequest<'_> {
    UpdateBackendRequest::new(api)
}

#[derive(Debug)]
pub struct BackendDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> BackendDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "lb/v1/zones/{zone}/backends/{backend_id}",
        )
        .require_path("zone")
        .require_path("backend_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Delete a backend of a given Load Balancer
///
/// Delete a backend of a given Load Balancer, specified by its backend ID. This action is irreversible and cannot be undone.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = backend_delete(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .send()
///     .await?;
/// ```
pub fn backend_delete(api: &ApiClient) -> BackendDeleteRequest<'_> {
    BackendDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateHealthCheckRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1HealthCheck>,
}

impl<'a> UpdateHealthCheckRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "lb/v1/zones/{zone}/backends/{backend_id}/healthcheck",
        )
        .require_path("zone")
        .require_path("backend_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1HealthCheck> {
        self.builder.send().await
    }
}
/// Update a health check for a given backend
///
/// Update the configuration of the health check performed by a given backend to verify the health of its backend servers, identified by its backend ID. Note that the request type is PUT and not PATCH. You must set all parameters.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}/healthcheck`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_health_check(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_health_check(api: &ApiClient) -> UpdateHealthCheckRequest<'_> {
    UpdateHealthCheckRequest::new(api)
}

#[derive(Debug)]
pub struct AddBackendServersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> AddBackendServersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "lb/v1/zones/{zone}/backends/{backend_id}/servers",
        )
        .require_path("zone")
        .require_path("backend_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Add a set of backend servers to a given backend
///
/// For a given backend specified by its backend ID, add a set of backend servers (identified by their IP addresses) it should forward traffic to. These will be appended to any existing set of backend servers for this backend.
///
/// **HTTP Method:** `POST`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}/servers`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = add_backend_servers(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn add_backend_servers(api: &ApiClient) -> AddBackendServersRequest<'_> {
    AddBackendServersRequest::new(api)
}

#[derive(Debug)]
pub struct SetBackendServersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> SetBackendServersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "lb/v1/zones/{zone}/backends/{backend_id}/servers",
        )
        .require_path("zone")
        .require_path("backend_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Define all backend servers for a given backend
///
/// For a given backend specified by its backend ID, define the set of backend servers (identified by their IP addresses) that it should forward traffic to. Any existing backend servers configured for this backend will be removed.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}/servers`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = set_backend_servers(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_backend_servers(api: &ApiClient) -> SetBackendServersRequest<'_> {
    SetBackendServersRequest::new(api)
}

#[derive(Debug)]
pub struct RemoveBackendServersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> RemoveBackendServersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "lb/v1/zones/{zone}/backends/{backend_id}/servers",
        )
        .require_path("zone")
        .require_path("backend_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("backend_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Remove a set of servers for a given backend
///
/// For a given backend specified by its backend ID, remove the specified backend servers (identified by their IP addresses) so that it no longer forwards traffic to them.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/lb/v1/zones/{zone}/backends/{backend_id}/servers`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `backend_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = remove_backend_servers(&api)
///     .with_zone("zone")
///     .with_backend_id("backend_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn remove_backend_servers(api: &ApiClient) -> RemoveBackendServersRequest<'_> {
    RemoveBackendServersRequest::new(api)
}

#[derive(Debug)]
pub struct ListBackendStatsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1ListBackendStatsResponse>,
}

impl<'a> ListBackendStatsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "lb/v1/zones/{zone}/lbs/{lb_id}/backend-stats",
        )
        .require_path("zone")
        .require_path("lb_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_lb_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("lb_id", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub fn with_backend_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("backend_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1ListBackendStatsResponse> {
        self.builder.send().await
    }
}
/// List backend server statistics
///
/// List information about your backend servers, including their state and the result of their last health check.
///
/// **HTTP Method:** `GET`
/// **Path:** `/lb/v1/zones/{zone}/lbs/{lb_id}/backend-stats`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `lb_id` (path, required)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
/// - `backend_id` (query,optional)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_backend_stats(&api)
///     .with_zone("zone")
///     .with_lb_id("lb_id")
///     .with_page("page")
///     .with_page_size("page_size")
///     .with_backend_id("backend_id")
///     .send()
///     .await?;
/// ```
pub fn list_backend_stats(api: &ApiClient) -> ListBackendStatsRequest<'_> {
    ListBackendStatsRequest::new(api)
}

#[derive(Debug)]
pub struct ListBackendsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1ListBackendsResponse>,
}

impl<'a> ListBackendsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "lb/v1/zones/{zone}/lbs/{lb_id}/backends")
                .require_path("zone")
                .require_path("lb_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_lb_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("lb_id", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1ListBackendsResponse> {
        self.builder.send().await
    }
}
/// List the backends of a given Load Balancer
///
/// List all the backends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each backend. The response is an array of backend objects, containing full details of each one including their configuration parameters such as protocol, port and forwarding algorithm.
///
/// **HTTP Method:** `GET`
/// **Path:** `/lb/v1/zones/{zone}/lbs/{lb_id}/backends`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `lb_id` (path, required)
/// - `name` (query,optional)
/// - `order_by` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_backends(&api)
///     .with_zone("zone")
///     .with_lb_id("lb_id")
///     .with_name("name")
///     .with_order_by("order_by")
///     .with_page("page")
///     .with_page_size("page_size")
///     .send()
///     .await?;
/// ```
pub fn list_backends(api: &ApiClient) -> ListBackendsRequest<'_> {
    ListBackendsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateBackendRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayLbV1Backend>,
}

impl<'a> CreateBackendRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "lb/v1/zones/{zone}/lbs/{lb_id}/backends")
                .require_path("zone")
                .require_path("lb_id")
                .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_lb_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("lb_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayLbV1Backend> {
        self.builder.send().await
    }
}
/// Create a backend for a given Load Balancer
///
/// Create a new backend for a given Load Balancer, specifying its full configuration including protocol, port and forwarding algorithm.
///
/// **HTTP Method:** `POST`
/// **Path:** `/lb/v1/zones/{zone}/lbs/{lb_id}/backends`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `lb_id` (path, required)
///
/// # Example
/// ```no_run
/// use loadbalancer::{ ApiClient, apis::backends };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_backend(&api)
///     .with_zone("zone")
///     .with_lb_id("lb_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_backend(api: &ApiClient) -> CreateBackendRequest<'_> {
    CreateBackendRequest::new(api)
}
