// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_instance_v1_attach_server_file_system_response::ScalewayInstanceV1AttachServerFileSystemResponse;
use crate::models::scaleway_instance_v1_attach_server_volume_response::ScalewayInstanceV1AttachServerVolumeResponse;
use crate::models::scaleway_instance_v1_create_server_response::ScalewayInstanceV1CreateServerResponse;
use crate::models::scaleway_instance_v1_detach_server_file_system_response::ScalewayInstanceV1DetachServerFileSystemResponse;
use crate::models::scaleway_instance_v1_detach_server_volume_response::ScalewayInstanceV1DetachServerVolumeResponse;
use crate::models::scaleway_instance_v1_get_server_response::ScalewayInstanceV1GetServerResponse;
use crate::models::scaleway_instance_v1_list_server_actions_response::ScalewayInstanceV1ListServerActionsResponse;
use crate::models::scaleway_instance_v1_list_servers_response::ScalewayInstanceV1ListServersResponse;
use crate::models::scaleway_instance_v1_server_action_response::ScalewayInstanceV1ServerActionResponse;
use crate::models::scaleway_instance_v1_server_compatible_types::ScalewayInstanceV1ServerCompatibleTypes;
use crate::models::scaleway_instance_v1_update_server_response::ScalewayInstanceV1UpdateServerResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListServersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1ListServersResponse>,
}

impl<'a> ListServersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "instance/v1/zones/{zone}/servers")
            .require_path("zone");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_per_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("per_page", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_organization(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization", value);
        self
    }
    pub fn with_project(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_private_ip(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("private_ip", value);
        self
    }
    pub fn with_without_ip(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("without_ip", value);
        self
    }
    pub fn with_with_ip(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("with_ip", value);
        self
    }
    pub fn with_commercial_type(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("commercial_type", value);
        self
    }
    pub fn with_state(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("state", value);
        self
    }
    pub fn with_tags(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tags", value);
        self
    }
    pub fn with_private_network(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("private_network", value);
        self
    }
    pub fn with_order(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order", value);
        self
    }
    pub fn with_private_networks(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("private_networks", value);
        self
    }
    pub fn with_private_nic_mac_address(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("private_nic_mac_address", value);
        self
    }
    pub fn with_servers(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("servers", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1ListServersResponse> {
        self.builder.send().await
    }
}
/// List all Instances
///
/// List all Instances in a specified Availability Zone, e.g. `fr-par-1`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/instance/v1/zones/{zone}/servers`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `per_page` (query,optional)
/// - `page` (query,optional)
/// - `organization` (query,optional)
/// - `project` (query,optional)
/// - `name` (query,optional)
/// - `private_ip` (query,optional)
/// - `without_ip` (query,optional)
/// - `with_ip` (query,optional)
/// - `commercial_type` (query,optional)
/// - `state` (query,optional)
/// - `tags` (query,optional)
/// - `private_network` (query,optional)
/// - `order` (query,optional)
/// - `private_networks` (query,optional)
/// - `private_nic_mac_address` (query,optional)
/// - `servers` (query,optional)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_servers(&api)
///     .with_zone("zone")
///     .with_per_page("per_page")
///     .with_page("page")
///     .with_organization("organization")
///     .with_project("project")
///     .with_name("name")
///     .with_private_ip("private_ip")
///     .with_without_ip("without_ip")
///     .with_with_ip("with_ip")
///     .with_commercial_type("commercial_type")
///     .with_state("state")
///     .with_tags("tags")
///     .with_private_network("private_network")
///     .with_order("order")
///     .with_private_networks("private_networks")
///     .with_private_nic_mac_address("private_nic_mac_address")
///     .with_servers("servers")
///     .send()
///     .await?;
/// ```
pub fn list_servers(api: &ApiClient) -> ListServersRequest<'_> {
    ListServersRequest::new(api)
}

#[derive(Debug)]
pub struct CreateServerRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1CreateServerResponse>,
}

impl<'a> CreateServerRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "instance/v1/zones/{zone}/servers")
            .require_path("zone")
            .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1CreateServerResponse> {
        self.builder.send().await
    }
}
/// Create an Instance
///
/// Create a new Instance of the specified commercial type in the specified zone. Pay attention to the volumes parameter, which takes an object which can be used in different ways to achieve different behaviors.
/// Get more information in the [Technical Information](#technical-information) section of the introduction.
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers`
///
/// **Parameters**
/// - `zone` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_server(&api)
///     .with_zone("zone")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_server(api: &ApiClient) -> CreateServerRequest<'_> {
    CreateServerRequest::new(api)
}

#[derive(Debug)]
pub struct ServerRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1GetServerResponse>,
}

impl<'a> ServerRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "instance/v1/zones/{zone}/servers/{server_id}",
        )
        .require_path("zone")
        .require_path("server_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1GetServerResponse> {
        self.builder.send().await
    }
}
/// Get an Instance
///
/// Get the details of a specified Instance.
///
/// **HTTP Method:** `GET`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = server(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .send()
///     .await?;
/// ```
pub fn server(api: &ApiClient) -> ServerRequest<'_> {
    ServerRequest::new(api)
}

#[derive(Debug)]
pub struct ServerDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ServerDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "instance/v1/zones/{zone}/servers/{server_id}",
        )
        .require_path("zone")
        .require_path("server_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Delete an Instance
///
/// Delete the Instance with the specified ID.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = server_delete(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .send()
///     .await?;
/// ```
pub fn server_delete(api: &ApiClient) -> ServerDeleteRequest<'_> {
    ServerDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateServerRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1UpdateServerResponse>,
}

impl<'a> UpdateServerRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "instance/v1/zones/{zone}/servers/{server_id}",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1UpdateServerResponse> {
        self.builder.send().await
    }
}
/// Update an Instance
///
/// Update the Instance information, such as name, boot mode, or tags.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_server(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_server(api: &ApiClient) -> UpdateServerRequest<'_> {
    UpdateServerRequest::new(api)
}

#[derive(Debug)]
pub struct ListServerActionsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1ListServerActionsResponse>,
}

impl<'a> ListServerActionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "instance/v1/zones/{zone}/servers/{server_id}/action",
        )
        .require_path("zone")
        .require_path("server_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1ListServerActionsResponse> {
        self.builder.send().await
    }
}
/// List Instance actions
///
/// List all actions (e.g. power on, power off, reboot) that can currently be performed on an Instance.
///
/// **HTTP Method:** `GET`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/action`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_server_actions(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .send()
///     .await?;
/// ```
pub fn list_server_actions(api: &ApiClient) -> ListServerActionsRequest<'_> {
    ListServerActionsRequest::new(api)
}

#[derive(Debug)]
pub struct ServerActionRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1ServerActionResponse>,
}

impl<'a> ServerActionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "instance/v1/zones/{zone}/servers/{server_id}/action",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1ServerActionResponse> {
        self.builder.send().await
    }
}
/// Perform action
///
/// Perform an action on an Instance.
/// Available actions are:
/// * `poweron`: Start a stopped Instance.
/// * `poweroff`: Fully stop the Instance and release the hypervisor slot.
/// * `stop_in_place`: Stop the Instance, but keep the slot on the hypervisor.
/// * `reboot`: Stop the instance and restart it.
/// * `backup`:  Create an image with all the volumes of an Instance.
/// * `terminate`: Delete the Instance along with its attached local volumes.
/// * `enable_routed_ip`: Migrate the Instance to the new network stack.
///
/// The `terminate` action will result in the deletion of `l_ssd` and `scratch` volumes types, `sbs_volume` volumes will only be detached.
/// If you want to preserve your `l_ssd` volumes, you should stop your Instance, detach the volumes to be preserved, then delete your Instance.
///
/// The `backup` action can be done with:
/// * No `volumes` key in the body: an image is created with snapshots of all the server volumes, except for the `scratch` volumes types.
/// * `volumes` key in the body with a dictionary as value, in this dictionary volumes UUID as keys and empty dictionaries as values : an image is created with the snapshots of the volumes in `volumes` key. `scratch` volumes types can't be shapshotted.
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/action`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = server_action(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn server_action(api: &ApiClient) -> ServerActionRequest<'_> {
    ServerActionRequest::new(api)
}

#[derive(Debug)]
pub struct AttachServerFileSystemRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1AttachServerFileSystemResponse>,
}

impl<'a> AttachServerFileSystemRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "instance/v1/zones/{zone}/servers/{server_id}/attach-filesystem",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1AttachServerFileSystemResponse> {
        self.builder.send().await
    }
}
/// Attach a filesystem volume to an Instance
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/attach-filesystem`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = attach_server_file_system(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn attach_server_file_system(api: &ApiClient) -> AttachServerFileSystemRequest<'_> {
    AttachServerFileSystemRequest::new(api)
}

#[derive(Debug)]
pub struct AttachServerVolumeRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1AttachServerVolumeResponse>,
}

impl<'a> AttachServerVolumeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "instance/v1/zones/{zone}/servers/{server_id}/attach-volume",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1AttachServerVolumeResponse> {
        self.builder.send().await
    }
}
/// Attach a volume to an Instance
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/attach-volume`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = attach_server_volume(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn attach_server_volume(api: &ApiClient) -> AttachServerVolumeRequest<'_> {
    AttachServerVolumeRequest::new(api)
}

#[derive(Debug)]
pub struct ServerCompatibleTypesRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1ServerCompatibleTypes>,
}

impl<'a> ServerCompatibleTypesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "instance/v1/zones/{zone}/servers/{server_id}/compatible-types",
        )
        .require_path("zone")
        .require_path("server_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1ServerCompatibleTypes> {
        self.builder.send().await
    }
}
/// Get Instance compatible types
///
/// Get compatible commercial types that can be used to update the Instance. The compatibility of an Instance offer is based on:
/// * the CPU architecture
/// * the OS type
/// * the required l_ssd storage size
/// * the required scratch storage size
/// If the specified Instance offer is flagged as end of service, the best compatible offer is the first returned.
///
/// **HTTP Method:** `GET`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/compatible-types`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = server_compatible_types(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .send()
///     .await?;
/// ```
pub fn server_compatible_types(api: &ApiClient) -> ServerCompatibleTypesRequest<'_> {
    ServerCompatibleTypesRequest::new(api)
}

#[derive(Debug)]
pub struct DetachServerFileSystemRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1DetachServerFileSystemResponse>,
}

impl<'a> DetachServerFileSystemRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "instance/v1/zones/{zone}/servers/{server_id}/detach-filesystem",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1DetachServerFileSystemResponse> {
        self.builder.send().await
    }
}
/// Detach a filesystem volume from an Instance
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/detach-filesystem`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = detach_server_file_system(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detach_server_file_system(api: &ApiClient) -> DetachServerFileSystemRequest<'_> {
    DetachServerFileSystemRequest::new(api)
}

#[derive(Debug)]
pub struct DetachServerVolumeRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayInstanceV1DetachServerVolumeResponse>,
}

impl<'a> DetachServerVolumeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "instance/v1/zones/{zone}/servers/{server_id}/detach-volume",
        )
        .require_path("zone")
        .require_path("server_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_server_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("server_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayInstanceV1DetachServerVolumeResponse> {
        self.builder.send().await
    }
}
/// Detach a volume from an Instance
///
/// **HTTP Method:** `POST`
/// **Path:** `/instance/v1/zones/{zone}/servers/{server_id}/detach-volume`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `server_id` (path, required)
///
/// # Example
/// ```no_run
/// use instance::{ ApiClient, apis::instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = detach_server_volume(&api)
///     .with_zone("zone")
///     .with_server_id("server_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detach_server_volume(api: &ApiClient) -> DetachServerVolumeRequest<'_> {
    DetachServerVolumeRequest::new(api)
}
