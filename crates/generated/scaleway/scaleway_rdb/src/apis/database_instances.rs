// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_rdb_v1_instance::ScalewayRdbV1Instance;
use crate::models::scaleway_rdb_v1_instance_log::ScalewayRdbV1InstanceLog;
use crate::models::scaleway_rdb_v1_instance_metrics::ScalewayRdbV1InstanceMetrics;
use crate::models::scaleway_rdb_v1_list_instance_logs_details_response::ScalewayRdbV1ListInstanceLogsDetailsResponse;
use crate::models::scaleway_rdb_v1_list_instance_logs_response::ScalewayRdbV1ListInstanceLogsResponse;
use crate::models::scaleway_rdb_v1_list_instances_response::ScalewayRdbV1ListInstancesResponse;
use crate::models::scaleway_rdb_v1_maintenance::ScalewayRdbV1Maintenance;
use crate::models::scaleway_rdb_v1_prepare_instance_logs_response::ScalewayRdbV1PrepareInstanceLogsResponse;
use crate::models::scaleway_std_file::ScalewayStdFile;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListInstancesRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ListInstancesResponse>,
}

impl<'a> ListInstancesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "rdb/v1/regions/{region}/instances")
            .require_path("region");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_tags(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tags", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_organization_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization_id", value);
        self
    }
    pub fn with_project_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project_id", value);
        self
    }
    pub fn with_has_maintenances(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("has_maintenances", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ListInstancesResponse> {
        self.builder.send().await
    }
}
/// List Database Instances
///
/// List all Database Instances in the specified region, for a given Scaleway Organization or Scaleway Project. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags` and `name`. For the `name` parameter, the value you include will be checked against the whole name string to see if it includes the string you put in the parameter.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances`
///
/// **Parameters**
/// - `region` (path, required)
/// - `tags` (query,optional)
/// - `name` (query,optional)
/// - `order_by` (query,optional)
/// - `organization_id` (query,optional)
/// - `project_id` (query,optional)
/// - `has_maintenances` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_instances(&api)
///     .with_region("region")
///     .with_tags("tags")
///     .with_name("name")
///     .with_order_by("order_by")
///     .with_organization_id("organization_id")
///     .with_project_id("project_id")
///     .with_has_maintenances("has_maintenances")
///     .with_page("page")
///     .with_page_size("page_size")
///     .send()
///     .await?;
/// ```
pub fn list_instances(api: &ApiClient) -> ListInstancesRequest<'_> {
    ListInstancesRequest::new(api)
}

#[derive(Debug)]
pub struct CreateInstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> CreateInstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "rdb/v1/regions/{region}/instances")
                .require_path("region")
                .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Create a Database Instance
///
/// Create a new Database Instance. You must set the `engine`, `user_name`, `password` and `node_type` parameters. Optionally, you can specify the volume type and size.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances`
///
/// **Parameters**
/// - `region` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_instance(&api)
///     .with_region("region")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_instance(api: &ApiClient) -> CreateInstanceRequest<'_> {
    CreateInstanceRequest::new(api)
}

#[derive(Debug)]
pub struct InstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> InstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/instances/{instance_id}",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Get a Database Instance
///
/// Retrieve information about a given Database Instance, specified by the `region` and `instance_id` parameters. Its full details, including name, status, IP address and port, are returned in the response object.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = instance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .send()
///     .await?;
/// ```
pub fn instance(api: &ApiClient) -> InstanceRequest<'_> {
    InstanceRequest::new(api)
}

#[derive(Debug)]
pub struct InstanceDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> InstanceDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "rdb/v1/regions/{region}/instances/{instance_id}",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Delete a Database Instance
///
/// Delete a given Database Instance, specified by the `region` and `instance_id` parameters. Deleting a Database Instance is permanent, and cannot be undone. Note that upon deletion all your data will be lost.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = instance_delete(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .send()
///     .await?;
/// ```
pub fn instance_delete(api: &ApiClient) -> InstanceDeleteRequest<'_> {
    InstanceDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateInstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> UpdateInstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "rdb/v1/regions/{region}/instances/{instance_id}",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Update a Database Instance
///
/// Update the parameters of a Database Instance, including name, tags and backup schedule details.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_instance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_instance(api: &ApiClient) -> UpdateInstanceRequest<'_> {
    UpdateInstanceRequest::new(api)
}

#[derive(Debug)]
pub struct ApplyInstanceMaintenanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Maintenance>,
}

impl<'a> ApplyInstanceMaintenanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/apply-maintenance",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Maintenance> {
        self.builder.send().await
    }
}
/// Apply Database Instance maintenance
///
/// Apply maintenance tasks to your Database Instance. This will trigger pending maintenance tasks to start in your Database Instance and can generate service interruption. Maintenance tasks can be applied between `starts_at` and `stops_at` times, and are run directly by Scaleway at `forced_at` timestamp.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/apply-maintenance`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = apply_instance_maintenance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn apply_instance_maintenance(api: &ApiClient) -> ApplyInstanceMaintenanceRequest<'_> {
    ApplyInstanceMaintenanceRequest::new(api)
}

#[derive(Debug)]
pub struct InstanceCertificateRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayStdFile>,
}

impl<'a> InstanceCertificateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/instances/{instance_id}/certificate",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayStdFile> {
        self.builder.send().await
    }
}
/// Get the TLS certificate of a Database Instance
///
/// Retrieve information about the TLS certificate of a given Database Instance. Details like name and content are returned in the response.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/certificate`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = instance_certificate(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .send()
///     .await?;
/// ```
pub fn instance_certificate(api: &ApiClient) -> InstanceCertificateRequest<'_> {
    InstanceCertificateRequest::new(api)
}

#[derive(Debug)]
pub struct CloneInstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> CloneInstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/clone",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Clone a Database Instance
///
/// Clone a given Database Instance, specified by the `region` and `instance_id` parameters. The clone feature allows you to create a new Database Instance from an existing one. The clone includes all existing databases, users and permissions. You can create a clone on a Database Instance bigger than your current one.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/clone`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = clone_instance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn clone_instance(api: &ApiClient) -> CloneInstanceRequest<'_> {
    CloneInstanceRequest::new(api)
}

#[derive(Debug)]
pub struct ListInstanceLogsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ListInstanceLogsResponse>,
}

impl<'a> ListInstanceLogsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/instances/{instance_id}/logs",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ListInstanceLogsResponse> {
        self.builder.send().await
    }
}
/// List available logs of a Database Instance
///
/// List the available logs of a Database Instance. By default, the logs returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/logs`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
/// - `order_by` (query,optional)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_instance_logs(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_order_by("order_by")
///     .send()
///     .await?;
/// ```
pub fn list_instance_logs(api: &ApiClient) -> ListInstanceLogsRequest<'_> {
    ListInstanceLogsRequest::new(api)
}

#[derive(Debug)]
pub struct ListInstanceLogsDetailsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ListInstanceLogsDetailsResponse>,
}

impl<'a> ListInstanceLogsDetailsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/instances/{instance_id}/logs-details",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ListInstanceLogsDetailsResponse> {
        self.builder.send().await
    }
}
/// List remote Database Instance logs details
///
/// List remote log details. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/logs-details`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_instance_logs_details(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .send()
///     .await?;
/// ```
pub fn list_instance_logs_details(api: &ApiClient) -> ListInstanceLogsDetailsRequest<'_> {
    ListInstanceLogsDetailsRequest::new(api)
}

#[derive(Debug)]
pub struct InstanceMetricsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1InstanceMetrics>,
}

impl<'a> InstanceMetricsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/instances/{instance_id}/metrics",
        )
        .require_path("region")
        .require_path("instance_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_start_date(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("start_date", value);
        self
    }
    pub fn with_end_date(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("end_date", value);
        self
    }
    pub fn with_metric_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("metric_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1InstanceMetrics> {
        self.builder.send().await
    }
}
/// [deprecated] Get Database Instance metrics
///
/// Retrieve the time series metrics of a given Database Instance. You can define the period from which to retrieve metrics by specifying the `start_date` and `end_date`. This method is deprecated and will be removed in a future version.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/metrics`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
/// - `start_date` (query,optional)
/// - `end_date` (query,optional)
/// - `metric_name` (query,optional)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = instance_metrics(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_start_date("start_date")
///     .with_end_date("end_date")
///     .with_metric_name("metric_name")
///     .send()
///     .await?;
/// ```
pub fn instance_metrics(api: &ApiClient) -> InstanceMetricsRequest<'_> {
    InstanceMetricsRequest::new(api)
}

#[derive(Debug)]
pub struct PrepareInstanceLogsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1PrepareInstanceLogsResponse>,
}

impl<'a> PrepareInstanceLogsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/prepare-logs",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1PrepareInstanceLogsResponse> {
        self.builder.send().await
    }
}
/// Prepare logs of a Database Instance
///
/// Prepare your Database Instance logs. You can define the `start_date` and `end_date` parameters for your query. The download URL is returned in the response. Logs are recorded from 00h00 to 23h59 and then aggregated in a `.log` file once a day. Therefore, even if you specify a timeframe from which you want to get the logs, you will receive logs from the full 24 hours.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/prepare-logs`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = prepare_instance_logs(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn prepare_instance_logs(api: &ApiClient) -> PrepareInstanceLogsRequest<'_> {
    PrepareInstanceLogsRequest::new(api)
}

#[derive(Debug)]
pub struct PurgeInstanceLogsRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> PurgeInstanceLogsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/purge-logs",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Purge remote Database Instance logs
///
/// Purge a given remote log from a Database Instance. You can specify the `log_name` of the log you wish to clean from your Database Instance.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/purge-logs`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = purge_instance_logs(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn purge_instance_logs(api: &ApiClient) -> PurgeInstanceLogsRequest<'_> {
    PurgeInstanceLogsRequest::new(api)
}

#[derive(Debug)]
pub struct RenewInstanceCertificateRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> RenewInstanceCertificateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/renew-certificate",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Renew the TLS certificate of a Database Instance
///
/// Renew a TLS for a Database Instance. Renewing a certificate means that you will not be able to connect to your Database Instance using the previous certificate. You will also need to download and update the new certificate for all database clients.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/renew-certificate`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = renew_instance_certificate(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn renew_instance_certificate(api: &ApiClient) -> RenewInstanceCertificateRequest<'_> {
    RenewInstanceCertificateRequest::new(api)
}

#[derive(Debug)]
pub struct RestartInstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> RestartInstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/restart",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Restart Database Instance
///
/// Restart a given Database Instance, specified by the `region` and `instance_id` parameters. The status of the Database Instance returned in the response.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/restart`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = restart_instance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn restart_instance(api: &ApiClient) -> RestartInstanceRequest<'_> {
    RestartInstanceRequest::new(api)
}

#[derive(Debug)]
pub struct UpgradeInstanceRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> UpgradeInstanceRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/instances/{instance_id}/upgrade",
        )
        .require_path("region")
        .require_path("instance_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Upgrade a Database Instance
///
/// Upgrade your current Database Instance specifications like node type, high availability, volume, or the database engine version. Note that upon upgrade the `enable_ha` parameter can only be set to `true`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/instances/{instance_id}/upgrade`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = upgrade_instance(&api)
///     .with_region("region")
///     .with_instance_id("instance_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn upgrade_instance(api: &ApiClient) -> UpgradeInstanceRequest<'_> {
    UpgradeInstanceRequest::new(api)
}

#[derive(Debug)]
pub struct InstanceLogRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1InstanceLog>,
}

impl<'a> InstanceLogRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/logs/{instance_log_id}",
        )
        .require_path("region")
        .require_path("instance_log_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_instance_log_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("instance_log_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1InstanceLog> {
        self.builder.send().await
    }
}
/// Get given logs of a Database Instance
///
/// Retrieve information about the logs of a Database Instance. Specify the `instance_log_id` and `region` in your request to get information such as `download_url`, `status`, `expires_at` and `created_at` about your logs in the response.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/logs/{instance_log_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `instance_log_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::database_instances };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = instance_log(&api)
///     .with_region("region")
///     .with_instance_log_id("instance_log_id")
///     .send()
///     .await?;
/// ```
pub fn instance_log(api: &ApiClient) -> InstanceLogRequest<'_> {
    InstanceLogRequest::new(api)
}
