// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_rdb_v1_instance::ScalewayRdbV1Instance;
use crate::models::scaleway_rdb_v1_read_replica::ScalewayRdbV1ReadReplica;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct CreateReadReplicaRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ReadReplica>,
}

impl<'a> CreateReadReplicaRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "rdb/v1/regions/{region}/read-replicas")
                .require_path("region")
                .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ReadReplica> {
        self.builder.send().await
    }
}
/// Create a Read Replica
///
/// Create a new Read Replica of a Database Instance. You must specify the `region` and the `instance_id`. You can only create a maximum of 3 Read Replicas per Database Instance.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas`
///
/// **Parameters**
/// - `region` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_read_replica(&api)
///     .with_region("region")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_read_replica(api: &ApiClient) -> CreateReadReplicaRequest<'_> {
    CreateReadReplicaRequest::new(api)
}

#[derive(Debug)]
pub struct ReplicaRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ReadReplica>,
}

impl<'a> ReplicaRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "rdb/v1/regions/{region}/read-replicas/{read_replica_id}",
        )
        .require_path("region")
        .require_path("read_replica_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_read_replica_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("read_replica_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ReadReplica> {
        self.builder.send().await
    }
}
/// Get a Read Replica
///
/// Retrieve information about a Database Instance Read Replica. Full details about the Read Replica, like `endpoints`, `status`  and `region` are returned in the response.
///
/// **HTTP Method:** `GET`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas/{read_replica_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `read_replica_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = replica(&api)
///     .with_region("region")
///     .with_read_replica_id("read_replica_id")
///     .send()
///     .await?;
/// ```
pub fn replica(api: &ApiClient) -> ReplicaRequest<'_> {
    ReplicaRequest::new(api)
}

#[derive(Debug)]
pub struct ReplicaDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ReadReplica>,
}

impl<'a> ReplicaDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "rdb/v1/regions/{region}/read-replicas/{read_replica_id}",
        )
        .require_path("region")
        .require_path("read_replica_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_read_replica_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("read_replica_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ReadReplica> {
        self.builder.send().await
    }
}
/// Delete a Read Replica
///
/// Delete a Read Replica of a Database Instance. You must specify the `region` and `read_replica_id` parameters of the Read Replica you want to delete.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas/{read_replica_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `read_replica_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = replica_delete(&api)
///     .with_region("region")
///     .with_read_replica_id("read_replica_id")
///     .send()
///     .await?;
/// ```
pub fn replica_delete(api: &ApiClient) -> ReplicaDeleteRequest<'_> {
    ReplicaDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct CreateReadReplicaEndpointRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ReadReplica>,
}

impl<'a> CreateReadReplicaEndpointRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/read-replicas/{read_replica_id}/endpoints",
        )
        .require_path("region")
        .require_path("read_replica_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_read_replica_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("read_replica_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ReadReplica> {
        self.builder.send().await
    }
}
/// Create an endpoint for a Read Replica
///
/// Create a new endpoint for a Read Replica. Read Replicas can have at most one direct access and one Private Network endpoint.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas/{read_replica_id}/endpoints`
///
/// **Parameters**
/// - `region` (path, required)
/// - `read_replica_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_read_replica_endpoint(&api)
///     .with_region("region")
///     .with_read_replica_id("read_replica_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_read_replica_endpoint(api: &ApiClient) -> CreateReadReplicaEndpointRequest<'_> {
    CreateReadReplicaEndpointRequest::new(api)
}

#[derive(Debug)]
pub struct PromoteReadReplicaRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1Instance>,
}

impl<'a> PromoteReadReplicaRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/read-replicas/{read_replica_id}/promote",
        )
        .require_path("region")
        .require_path("read_replica_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_read_replica_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("read_replica_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1Instance> {
        self.builder.send().await
    }
}
/// Promote a Read Replica
///
/// Promote a Read Replica to Database Instance automatically.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas/{read_replica_id}/promote`
///
/// **Parameters**
/// - `region` (path, required)
/// - `read_replica_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = promote_read_replica(&api)
///     .with_region("region")
///     .with_read_replica_id("read_replica_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn promote_read_replica(api: &ApiClient) -> PromoteReadReplicaRequest<'_> {
    PromoteReadReplicaRequest::new(api)
}

#[derive(Debug)]
pub struct ResetReadReplicaRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRdbV1ReadReplica>,
}

impl<'a> ResetReadReplicaRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "rdb/v1/regions/{region}/read-replicas/{read_replica_id}/reset",
        )
        .require_path("region")
        .require_path("read_replica_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_read_replica_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("read_replica_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRdbV1ReadReplica> {
        self.builder.send().await
    }
}
/// Resync a Read Replica
///
/// When you resync a Read Replica, first it is reset, then its data is resynchronized from the primary node. Your Read Replica remains unavailable during the resync process. The duration of this process is proportional to the size of your Database Instance.
/// The configured endpoints do not change.
///
/// **HTTP Method:** `POST`
/// **Path:** `/rdb/v1/regions/{region}/read-replicas/{read_replica_id}/reset`
///
/// **Parameters**
/// - `region` (path, required)
/// - `read_replica_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforpostgresqlandmysql::{ ApiClient, apis::read_replicas };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = reset_read_replica(&api)
///     .with_region("region")
///     .with_read_replica_id("read_replica_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn reset_read_replica(api: &ApiClient) -> ResetReadReplicaRequest<'_> {
    ResetReadReplicaRequest::new(api)
}
