// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_k8s_v1_cluster::ScalewayK8sV1Cluster;
use crate::models::scaleway_k8s_v1_list_cluster_available_types_response::ScalewayK8sV1ListClusterAvailableTypesResponse;
use crate::models::scaleway_k8s_v1_list_cluster_available_versions_response::ScalewayK8sV1ListClusterAvailableVersionsResponse;
use crate::models::scaleway_k8s_v1_list_clusters_response::ScalewayK8sV1ListClustersResponse;
use crate::models::scaleway_std_file::ScalewayStdFile;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListClustersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1ListClustersResponse>,
}

impl<'a> ListClustersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "k8s/v1/regions/{region}/clusters")
            .require_path("region");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_organization_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization_id", value);
        self
    }
    pub fn with_project_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project_id", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_status(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("status", value);
        self
    }
    pub fn with_type_param(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("type", value);
        self
    }
    pub fn with_private_network_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("private_network_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1ListClustersResponse> {
        self.builder.send().await
    }
}
/// List Clusters
///
/// List all existing Kubernetes clusters in a specific region.
///
/// **HTTP Method:** `GET`
/// **Path:** `/k8s/v1/regions/{region}/clusters`
///
/// **Parameters**
/// - `region` (path, required)
/// - `organization_id` (query,optional)
/// - `project_id` (query,optional)
/// - `order_by` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
/// - `name` (query,optional)
/// - `status` (query,optional)
/// - `type` (query,optional)
/// - `private_network_id` (query,optional)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_clusters(&api)
///     .with_region("region")
///     .with_organization_id("organization_id")
///     .with_project_id("project_id")
///     .with_order_by("order_by")
///     .with_page("page")
///     .with_page_size("page_size")
///     .with_name("name")
///     .with_status("status")
///     .with_type_param("type")
///     .with_private_network_id("private_network_id")
///     .send()
///     .await?;
/// ```
pub fn list_clusters(api: &ApiClient) -> ListClustersRequest<'_> {
    ListClustersRequest::new(api)
}

#[derive(Debug)]
pub struct CreateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> CreateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "k8s/v1/regions/{region}/clusters")
            .require_path("region")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Create a new Cluster
///
/// Create a new Kubernetes cluster in a Scaleway region.
///
/// **HTTP Method:** `POST`
/// **Path:** `/k8s/v1/regions/{region}/clusters`
///
/// **Parameters**
/// - `region` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_cluster(&api)
///     .with_region("region")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_cluster(api: &ApiClient) -> CreateClusterRequest<'_> {
    CreateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> ClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "k8s/v1/regions/{region}/clusters/{cluster_id}",
        )
        .require_path("region")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Get a Cluster
///
/// Retrieve information about a specific Kubernetes cluster.
///
/// **HTTP Method:** `GET`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn cluster(api: &ApiClient) -> ClusterRequest<'_> {
    ClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> ClusterDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "k8s/v1/regions/{region}/clusters/{cluster_id}",
        )
        .require_path("region")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_with_additional_resources(mut self, value: impl Into<String>) -> Self {
        self.builder = self
            .builder
            .header_param("with_additional_resources", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Delete a Cluster
///
/// Delete a specific Kubernetes cluster and all its associated pools and nodes, and possibly its associated Load Balancers or Block Volumes.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
/// - `with_additional_resources` (query,required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster_delete(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_with_additional_resources("with_additional_resources")
///     .send()
///     .await?;
/// ```
pub fn cluster_delete(api: &ApiClient) -> ClusterDeleteRequest<'_> {
    ClusterDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> UpdateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "k8s/v1/regions/{region}/clusters/{cluster_id}",
        )
        .require_path("region")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Update a Cluster
///
/// Update information on a specific Kubernetes cluster. You can update details such as its name, description, tags and configuration. To upgrade a cluster, you will need to use the dedicated endpoint.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_cluster(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_cluster(api: &ApiClient) -> UpdateClusterRequest<'_> {
    UpdateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ListClusterAvailableTypesRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1ListClusterAvailableTypesResponse>,
}

impl<'a> ListClusterAvailableTypesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/available-types",
        )
        .require_path("region")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1ListClusterAvailableTypesResponse> {
        self.builder.send().await
    }
}
/// List available cluster types for a cluster
///
/// List the cluster types that a specific Kubernetes cluster is allowed to switch to.
///
/// **HTTP Method:** `GET`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/available-types`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_cluster_available_types(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn list_cluster_available_types(api: &ApiClient) -> ListClusterAvailableTypesRequest<'_> {
    ListClusterAvailableTypesRequest::new(api)
}

#[derive(Debug)]
pub struct ListClusterAvailableVersionsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1ListClusterAvailableVersionsResponse>,
}

impl<'a> ListClusterAvailableVersionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/available-versions",
        )
        .require_path("region")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1ListClusterAvailableVersionsResponse> {
        self.builder.send().await
    }
}
/// List available versions for a Cluster
///
/// List the versions that a specific Kubernetes cluster is allowed to upgrade to. Results will include every patch version greater than the current patch, as well as one minor version ahead of the current version. Any upgrade skipping a minor version will not work.
///
/// **HTTP Method:** `GET`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/available-versions`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_cluster_available_versions(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn list_cluster_available_versions(api: &ApiClient) -> ListClusterAvailableVersionsRequest<'_> {
    ListClusterAvailableVersionsRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterKubeConfigRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayStdFile>,
}

impl<'a> ClusterKubeConfigRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/kubeconfig",
        )
        .require_path("region")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_redacted(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("redacted", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayStdFile> {
        self.builder.send().await
    }
}
/// Download the kubeconfig for a Cluster
///
/// Download the Kubernetes cluster config file (also known as `kubeconfig`) for a specific cluster to use it with `kubectl`.
/// Tip: add `?dl=1` at the end of the URL to directly retrieve the base64 decoded kubeconfig. If you choose not to, the kubeconfig will be base64 encoded.
///
/// **HTTP Method:** `GET`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/kubeconfig`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
/// - `redacted` (query,optional)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster_kube_config(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_redacted("redacted")
///     .send()
///     .await?;
/// ```
pub fn cluster_kube_config(api: &ApiClient) -> ClusterKubeConfigRequest<'_> {
    ClusterKubeConfigRequest::new(api)
}

#[derive(Debug)]
pub struct ResetClusterAdminTokenRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ResetClusterAdminTokenRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/reset-admin-token",
        )
        .require_path("region")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Reset the admin token of a Cluster
///
/// Reset the admin token for a specific Kubernetes cluster. This will revoke the old admin token (which will not be usable afterwards) and create a new one. Note that you will need to download the kubeconfig again to keep interacting with the cluster.
///
/// **HTTP Method:** `POST`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/reset-admin-token`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = reset_cluster_admin_token(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn reset_cluster_admin_token(api: &ApiClient) -> ResetClusterAdminTokenRequest<'_> {
    ResetClusterAdminTokenRequest::new(api)
}

#[derive(Debug)]
pub struct SetClusterTypeRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> SetClusterTypeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/set-type",
        )
        .require_path("region")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Change the Cluster type
///
/// Change the type of a specific Kubernetes cluster. To see the possible values you can enter for the `type` field, [list available cluster types](#list-available-cluster-types-for-a-cluster).
///
/// **HTTP Method:** `POST`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/set-type`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = set_cluster_type(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn set_cluster_type(api: &ApiClient) -> SetClusterTypeRequest<'_> {
    SetClusterTypeRequest::new(api)
}

#[derive(Debug)]
pub struct UpgradeClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayK8sV1Cluster>,
}

impl<'a> UpgradeClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "k8s/v1/regions/{region}/clusters/{cluster_id}/upgrade",
        )
        .require_path("region")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayK8sV1Cluster> {
        self.builder.send().await
    }
}
/// Upgrade a Cluster
///
/// Upgrade a specific Kubernetes cluster and possibly its associated pools to a specific and supported Kubernetes version.
///
/// **HTTP Method:** `POST`
/// **Path:** `/k8s/v1/regions/{region}/clusters/{cluster_id}/upgrade`
///
/// **Parameters**
/// - `region` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use kubernetes::{ ApiClient, apis::clusters };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = upgrade_cluster(&api)
///     .with_region("region")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn upgrade_cluster(api: &ApiClient) -> UpgradeClusterRequest<'_> {
    UpgradeClusterRequest::new(api)
}
