// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Auto-generated client for the Cloudflavor SDK.

//!
//! # Usage
//! ```no_run
//! use webhostingoffer::{ApiClient, apis};
//! let api = ApiClient::builder("https://api.example.com")
//!     .build()
//!     .expect("client");
//! let _ = apis::offers::list_offers(&api)
//!     .path_param("id", "example")
//!     .send()
//!     .await;
//! ```

use reqwest::header::{HeaderMap, HeaderName, HeaderValue};
use reqwest::Client;
use reqwest::ClientBuilder;
use reqwest::Method;
use serde::de::DeserializeOwned;
use serde::Serialize;
use std::collections::{BTreeMap, BTreeSet};
use std::fmt;

pub type ApiResult<T> = Result<T, ApiError>;

#[derive(Debug)]
pub enum ApiError {
    Http(reqwest::Error),
    Serialization(serde_json::Error),
    MissingPathParam(String),
    MissingQueryParam(String),
    MissingHeaderParam(String),
    MissingBody,
}

impl fmt::Display for ApiError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ApiError::Http(err) => write!(f, "{err}"),
            ApiError::Serialization(err) => write!(f, "{err}"),
            ApiError::MissingPathParam(name) => write!(f, "missing path parameter `{name}`"),
            ApiError::MissingQueryParam(name) => write!(f, "missing query parameter `{name}`"),
            ApiError::MissingHeaderParam(name) => write!(f, "missing header `{name}`"),
            ApiError::MissingBody => write!(f, "request body is required"),
        }
    }
}

impl std::error::Error for ApiError {}

impl From<reqwest::Error> for ApiError {
    fn from(err: reqwest::Error) -> Self {
        Self::Http(err)
    }
}

impl From<serde_json::Error> for ApiError {
    fn from(err: serde_json::Error) -> Self {
        Self::Serialization(err)
    }
}

#[derive(Debug, Clone)]
pub struct ApiClient {
    inner: Client,
    base_url: String,
    auth_token: Option<String>,
    api_key: Option<String>,
    default_headers: HeaderMap,
    default_query: Vec<(String, String)>,
    default_path_params: BTreeMap<String, String>,
}

impl ApiClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        ApiClientBuilder::new(base_url)
            .build()
            .expect("failed to build HTTP client")
    }

    pub fn builder(base_url: impl Into<String>) -> ApiClientBuilder {
        ApiClientBuilder::new(base_url)
    }

    pub fn with_client(client: Client, base_url: impl Into<String>) -> Self {
        Self {
            inner: client,
            base_url: base_url.into(),
            auth_token: None,
            api_key: None,
            default_headers: HeaderMap::new(),
            default_query: Vec::new(),
            default_path_params: BTreeMap::new(),
        }
    }

    pub fn auth_header(&self) -> Option<&str> {
        self.auth_token.as_deref()
    }

    pub fn set_auth_token(&mut self, token: impl Into<String>) {
        self.auth_token = Some(token.into());
    }

    pub fn clear_auth_token(&mut self) {
        self.auth_token = None;
    }

    pub fn client(&self) -> &Client {
        &self.inner
    }

    pub fn base_url(&self) -> &str {
        &self.base_url
    }

    pub fn default_headers(&self) -> &HeaderMap {
        &self.default_headers
    }

    pub fn default_query_params(&self) -> &[(String, String)] {
        &self.default_query
    }

    fn default_path_params(&self) -> &BTreeMap<String, String> {
        &self.default_path_params
    }

    fn api_key(&self) -> Option<&str> {
        self.api_key.as_deref()
    }
}

#[derive(Debug)]
pub struct ApiClientBuilder {
    base_url: String,
    client_builder: ClientBuilder,
    auth_token: Option<String>,
    api_key: Option<String>,
    account_id: Option<String>,
    zone_id: Option<String>,
    default_headers: HeaderMap,
    default_query: Vec<(String, String)>,
}

impl ApiClientBuilder {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self {
            base_url: base_url.into(),
            client_builder: ClientBuilder::new(),
            auth_token: None,
            api_key: None,
            account_id: None,
            zone_id: None,
            default_headers: HeaderMap::new(),
            default_query: Vec::new(),
        }
    }

    pub fn api_token(mut self, token: impl Into<String>) -> Self {
        self.auth_token = Some(token.into());
        self
    }

    #[deprecated(note = "use api_token instead")]
    pub fn auth_token(self, token: impl Into<String>) -> Self {
        self.api_token(token)
    }

    pub fn api_key(mut self, key: impl Into<String>) -> Self {
        self.api_key = Some(key.into());
        eprintln!("warning: API keys are deprecated; prefer API tokens when possible");
        self
    }

    pub fn account_id(mut self, value: impl Into<String>) -> Self {
        self.account_id = Some(value.into());
        self
    }

    pub fn zone_id(mut self, value: impl Into<String>) -> Self {
        self.zone_id = Some(value.into());
        self
    }

    pub fn default_header(mut self, name: HeaderName, value: HeaderValue) -> Self {
        self.default_headers.insert(name, value);
        self
    }

    pub fn default_query_param(
        mut self,
        name: impl Into<String>,
        value: impl Into<String>,
    ) -> Self {
        self.default_query.push((name.into(), value.into()));
        self
    }

    pub fn configure_client(mut self, f: impl FnOnce(ClientBuilder) -> ClientBuilder) -> Self {
        self.client_builder = f(self.client_builder);
        self
    }

    pub fn build(self) -> Result<ApiClient, reqwest::Error> {
        if self.auth_token.is_some() && self.api_key.is_some() {
            panic!("api_token and api_key are mutually exclusive");
        }
        let client = self.client_builder.build()?;
        let mut default_path_params = BTreeMap::new();
        if let Some(account) = self.account_id {
            default_path_params.insert("account_id".to_string(), account);
        }
        if let Some(zone) = self.zone_id {
            default_path_params.insert("zone_id".to_string(), zone);
        }
        Ok(ApiClient {
            inner: client,
            base_url: self.base_url,
            auth_token: self.auth_token,
            api_key: self.api_key,
            default_headers: self.default_headers,
            default_query: self.default_query,
            default_path_params,
        })
    }
}

#[derive(Debug, Clone)]
pub struct ApiRequestBuilder<'a, Resp> {
    api: &'a ApiClient,
    method: Method,
    path: String,
    auth_token: Option<String>,
    path_params: BTreeMap<String, String>,
    required_paths: BTreeSet<String>,
    query_params: BTreeMap<String, String>,
    required_query: BTreeSet<String>,
    header_params: BTreeMap<String, String>,
    required_headers: BTreeSet<String>,
    body: Option<serde_json::Value>,
    body_required: bool,
    _marker: std::marker::PhantomData<Resp>,
}

impl<'a, Resp> ApiRequestBuilder<'a, Resp> {
    pub fn new(api: &'a ApiClient, method: Method, path: impl Into<String>) -> Self {
        Self {
            api,
            method,
            path: path.into(),
            auth_token: None,
            path_params: api.default_path_params().clone(),
            required_paths: BTreeSet::new(),
            query_params: BTreeMap::new(),
            required_query: BTreeSet::new(),
            header_params: BTreeMap::new(),
            required_headers: BTreeSet::new(),
            body: None,
            body_required: false,
            _marker: std::marker::PhantomData,
        }
    }

    pub fn auth_token(mut self, token: impl Into<String>) -> Self {
        self.auth_token = Some(token.into());
        self
    }

    pub fn require_path(mut self, name: impl Into<String>) -> Self {
        self.required_paths.insert(name.into());
        self
    }

    pub fn require_query(mut self, name: impl Into<String>) -> Self {
        self.required_query.insert(name.into());
        self
    }

    pub fn require_header(mut self, name: impl Into<String>) -> Self {
        self.required_headers.insert(name.into());
        self
    }

    pub fn require_body(mut self) -> Self {
        self.body_required = true;
        self
    }

    pub fn path_param(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.path_params.insert(name.into(), value.into());
        self
    }

    pub fn query_param(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.query_params.insert(name.into(), value.into());
        self
    }

    pub fn query_param_opt(
        mut self,
        name: impl Into<String>,
        value: Option<impl Into<String>>,
    ) -> Self {
        if let Some(val) = value {
            self.query_params.insert(name.into(), val.into());
        }
        self
    }

    pub fn header_param(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.header_params.insert(name.into(), value.into());
        self
    }

    pub fn header_param_opt(
        mut self,
        name: impl Into<String>,
        value: Option<impl Into<String>>,
    ) -> Self {
        if let Some(val) = value {
            self.header_params.insert(name.into(), val.into());
        }
        self
    }

    pub fn json_body(mut self, body: impl Serialize) -> Result<Self, ApiError> {
        let value = serde_json::to_value(body)?;
        self.body = Some(value);
        Ok(self)
    }

    pub async fn send(self) -> ApiResult<Resp>
    where
        Resp: DeserializeOwned,
    {
        self.ensure_requirements()?;
        let mut path = self.path;
        for (name, value) in self.path_params.iter() {
            let needle = format!("{}{}{}", "{", name, "}");
            path = path.replace(&needle, value);
        }

        if path.contains('{') {
            return Err(ApiError::MissingPathParam(path));
        }

        let mut req = self.api.client().request(
            self.method.clone(),
            format!("{}/{}", self.api.base_url().trim_end_matches('/'), path),
        );

        for (name, value) in self.api.default_headers().iter() {
            req = req.header(name, value);
        }

        for (name, value) in self.header_params.iter() {
            req = req.header(name, value);
        }

        let mut query_pairs: Vec<(String, String)> =
            self.api.default_query_params().iter().cloned().collect();
        query_pairs.extend(self.query_params.into_iter());

        if !query_pairs.is_empty() {
            req = req.query(&query_pairs);
        }

        if let Some(token) = self
            .auth_token
            .as_deref()
            .or_else(|| self.api.auth_header())
        {
            req = req.bearer_auth(token);
        } else if let Some(key) = self.api.api_key() {
            req = req.header("X-Auth-Key", key);
        }

        if let Some(body) = self.body {
            req = req.json(&body);
        }

        let response = req.send().await?.error_for_status()?;
        Ok(response.json::<Resp>().await?)
    }

    fn ensure_requirements(&self) -> ApiResult<()> {
        for name in &self.required_paths {
            if !self.path_params.contains_key(name) {
                return Err(ApiError::MissingPathParam(name.clone()));
            }
        }
        for name in &self.required_query {
            if !self.query_params.contains_key(name) {
                return Err(ApiError::MissingQueryParam(name.clone()));
            }
        }
        for name in &self.required_headers {
            if !self.header_params.contains_key(name) {
                return Err(ApiError::MissingHeaderParam(name.clone()));
            }
        }
        if self.body_required && self.body.is_none() {
            return Err(ApiError::MissingBody);
        }
        Ok(())
    }
}

pub mod apis;

pub mod models;
