// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_redis_v1_cluster::ScalewayRedisV1Cluster;
use crate::models::scaleway_redis_v1_cluster_metrics_response::ScalewayRedisV1ClusterMetricsResponse;
use crate::models::scaleway_redis_v1_list_clusters_response::ScalewayRedisV1ListClustersResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListClustersRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1ListClustersResponse>,
}

impl<'a> ListClustersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "redis/v1/zones/{zone}/clusters")
            .require_path("zone");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_tags(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tags", value);
        self
    }
    pub fn with_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("name", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_project_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project_id", value);
        self
    }
    pub fn with_organization_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization_id", value);
        self
    }
    pub fn with_version(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("version", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1ListClustersResponse> {
        self.builder.send().await
    }
}
/// List Redis™ Database Instances
///
/// List all Redis™ Database Instances (Redis™ cluster) in the specified zone. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags`, `name`, `organization_id` and `version`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/redis/v1/zones/{zone}/clusters`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `tags` (query,optional)
/// - `name` (query,optional)
/// - `order_by` (query,optional)
/// - `project_id` (query,optional)
/// - `organization_id` (query,optional)
/// - `version` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_clusters(&api)
///     .with_zone("zone")
///     .with_tags("tags")
///     .with_name("name")
///     .with_order_by("order_by")
///     .with_project_id("project_id")
///     .with_organization_id("organization_id")
///     .with_version("version")
///     .with_page("page")
///     .with_page_size("page_size")
///     .send()
///     .await?;
/// ```
pub fn list_clusters(api: &ApiClient) -> ListClustersRequest<'_> {
    ListClustersRequest::new(api)
}

#[derive(Debug)]
pub struct CreateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1Cluster>,
}

impl<'a> CreateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "redis/v1/zones/{zone}/clusters")
            .require_path("zone")
            .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1Cluster> {
        self.builder.send().await
    }
}
/// Create a Redis™ Database Instance
///
/// Create a new Redis™ Database Instance (Redis™ cluster). You must set the `zone`, `project_id`, `version`, `node_type`, `user_name` and `password` parameters. Optionally you can define `acl_rules`, `endpoints`, `tls_enabled` and `cluster_settings`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/redis/v1/zones/{zone}/clusters`
///
/// **Parameters**
/// - `zone` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = create_cluster(&api)
///     .with_zone("zone")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_cluster(api: &ApiClient) -> CreateClusterRequest<'_> {
    CreateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1Cluster>,
}

impl<'a> ClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "redis/v1/zones/{zone}/clusters/{cluster_id}",
        )
        .require_path("zone")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1Cluster> {
        self.builder.send().await
    }
}
/// Get a Redis™ Database Instance
///
/// Retrieve information about a Redis™ Database Instance (Redis™ cluster). Specify the `cluster_id` and `region` in your request to get information such as `id`, `status`, `version`, `tls_enabled`, `cluster_settings`, `upgradable_versions` and `endpoints` about your cluster in the response.
///
/// **HTTP Method:** `GET`
/// **Path:** `/redis/v1/zones/{zone}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster(&api)
///     .with_zone("zone")
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn cluster(api: &ApiClient) -> ClusterRequest<'_> {
    ClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterDeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1Cluster>,
}

impl<'a> ClusterDeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "redis/v1/zones/{zone}/clusters/{cluster_id}",
        )
        .require_path("zone")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1Cluster> {
        self.builder.send().await
    }
}
/// Delete a Redis™ Database Instance
///
/// Delete a Redis™ Database Instance (Redis™ cluster), specified by the `region` and `cluster_id` parameters. Deleting a Database Instance is permanent, and cannot be undone. Note that upon deletion all your data will be lost.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/redis/v1/zones/{zone}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster_delete(&api)
///     .with_zone("zone")
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn cluster_delete(api: &ApiClient) -> ClusterDeleteRequest<'_> {
    ClusterDeleteRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1Cluster>,
}

impl<'a> UpdateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PATCH,
            "redis/v1/zones/{zone}/clusters/{cluster_id}",
        )
        .require_path("zone")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1Cluster> {
        self.builder.send().await
    }
}
/// Update a Redis™ Database Instance
///
/// Update the parameters of a Redis™ Database Instance (Redis™ cluster), including `name`, `tags`, `user_name` and `password`.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/redis/v1/zones/{zone}/clusters/{cluster_id}`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_cluster(&api)
///     .with_zone("zone")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_cluster(api: &ApiClient) -> UpdateClusterRequest<'_> {
    UpdateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct ClusterMetricsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1ClusterMetricsResponse>,
}

impl<'a> ClusterMetricsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "redis/v1/zones/{zone}/clusters/{cluster_id}/metrics",
        )
        .require_path("zone")
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_start_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("start_at", value);
        self
    }
    pub fn with_end_at(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("end_at", value);
        self
    }
    pub fn with_metric_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("metric_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1ClusterMetricsResponse> {
        self.builder.send().await
    }
}
/// Get metrics of a Redis™ Database Instance
///
/// Retrieve the metrics of a Redis™ Database Instance (Redis™ cluster). You can define the period from which to retrieve metrics by specifying the `start_date` and `end_date`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/redis/v1/zones/{zone}/clusters/{cluster_id}/metrics`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `cluster_id` (path, required)
/// - `start_at` (query,optional)
/// - `end_at` (query,optional)
/// - `metric_name` (query,optional)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cluster_metrics(&api)
///     .with_zone("zone")
///     .with_cluster_id("cluster_id")
///     .with_start_at("start_at")
///     .with_end_at("end_at")
///     .with_metric_name("metric_name")
///     .send()
///     .await?;
/// ```
pub fn cluster_metrics(api: &ApiClient) -> ClusterMetricsRequest<'_> {
    ClusterMetricsRequest::new(api)
}

#[derive(Debug)]
pub struct MigrateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayRedisV1Cluster>,
}

impl<'a> MigrateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "redis/v1/zones/{zone}/clusters/{cluster_id}/migrate",
        )
        .require_path("zone")
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_zone(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("zone", value);
        self
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayRedisV1Cluster> {
        self.builder.send().await
    }
}
/// Scale up a Redis™ Database Instance
///
/// Upgrade your Redis™ Database Instance, either by upgrading to a bigger node type (vertical scaling) or by adding more nodes to your Database Instance to increase your number of endpoints and distribute cache (horizontal scaling, available for clusters only). Note that scaling horizontally your Redis™ Database Instance will not renew its TLS certificate. In order to refresh the TLS certificate, you must use the Renew TLS certificate endpoint.
///
/// **HTTP Method:** `POST`
/// **Path:** `/redis/v1/zones/{zone}/clusters/{cluster_id}/migrate`
///
/// **Parameters**
/// - `zone` (path, required)
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use manageddatabaseforredis™::{ ApiClient, apis::redis_database_instance };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = migrate_cluster(&api)
///     .with_zone("zone")
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn migrate_cluster(api: &ApiClient) -> MigrateClusterRequest<'_> {
    MigrateClusterRequest::new(api)
}
