// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::scaleway_ipam_v1_ip::ScalewayIpamV1Ip;
use crate::models::scaleway_ipam_v1_list_i_ps_response::ScalewayIpamV1ListIPsResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListIPsRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1ListIPsResponse>,
}

impl<'a> ListIPsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "ipam/v1/regions/{region}/ips")
            .require_path("region");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_order_by(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("order_by", value);
        self
    }
    pub fn with_page(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page", value);
        self
    }
    pub fn with_page_size(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("page_size", value);
        self
    }
    pub fn with_project_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("project_id", value);
        self
    }
    pub fn with_vpc_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("vpc_id", value);
        self
    }
    pub fn with_attached(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("attached", value);
        self
    }
    pub fn with_resource_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("resource_name", value);
        self
    }
    pub fn with_resource_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("resource_id", value);
        self
    }
    pub fn with_resource_ids(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("resource_ids", value);
        self
    }
    pub fn with_resource_type(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("resource_type", value);
        self
    }
    pub fn with_resource_types(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("resource_types", value);
        self
    }
    pub fn with_mac_address(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("mac_address", value);
        self
    }
    pub fn with_tags(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("tags", value);
        self
    }
    pub fn with_organization_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("organization_id", value);
        self
    }
    pub fn with_is_ipv6(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("is_ipv6", value);
        self
    }
    pub fn with_ip_ids(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("ip_ids", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1ListIPsResponse> {
        self.builder.send().await
    }
}
/// List existing IPs
///
/// List existing IPs in the specified region using various filters. For example, you can filter for IPs within a specified Private Network, or for public IPs within a specified Project. By default, the IPs returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
///
/// **HTTP Method:** `GET`
/// **Path:** `/ipam/v1/regions/{region}/ips`
///
/// **Parameters**
/// - `region` (path, required)
/// - `order_by` (query,optional)
/// - `page` (query,optional)
/// - `page_size` (query,optional)
/// - `project_id` (query,optional)
/// - `vpc_id` (query,optional)
/// - `attached` (query,optional)
/// - `resource_name` (query,optional)
/// - `resource_id` (query,optional)
/// - `resource_ids` (query,optional)
/// - `resource_type` (query,optional)
/// - `resource_types` (query,optional)
/// - `mac_address` (query,optional)
/// - `tags` (query,optional)
/// - `organization_id` (query,optional)
/// - `is_ipv6` (query,optional)
/// - `ip_ids` (query,optional)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_i_ps(&api)
///     .with_region("region")
///     .with_order_by("order_by")
///     .with_page("page")
///     .with_page_size("page_size")
///     .with_project_id("project_id")
///     .with_vpc_id("vpc_id")
///     .with_attached("attached")
///     .with_resource_name("resource_name")
///     .with_resource_id("resource_id")
///     .with_resource_ids("resource_ids")
///     .with_resource_type("resource_type")
///     .with_resource_types("resource_types")
///     .with_mac_address("mac_address")
///     .with_tags("tags")
///     .with_organization_id("organization_id")
///     .with_is_ipv6("is_ipv6")
///     .with_ip_ids("ip_ids")
///     .send()
///     .await?;
/// ```
pub fn list_i_ps(api: &ApiClient) -> ListIPsRequest<'_> {
    ListIPsRequest::new(api)
}

#[derive(Debug)]
pub struct BookIpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> BookIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "ipam/v1/regions/{region}/ips")
            .require_path("region")
            .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Reserve a new IP
///
/// Reserve a new IP from the specified source. Currently IPs can only be reserved from a Private Network.
///
/// **HTTP Method:** `POST`
/// **Path:** `/ipam/v1/regions/{region}/ips`
///
/// **Parameters**
/// - `region` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = book_ip(&api)
///     .with_region("region")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn book_ip(api: &ApiClient) -> BookIpRequest<'_> {
    BookIpRequest::new(api)
}

#[derive(Debug)]
pub struct IpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> IpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "ipam/v1/regions/{region}/ips/{ip_id}")
                .require_path("region")
                .require_path("ip_id");

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Get an IP
///
/// Retrieve details of an existing IP, specified by its IP ID.
///
/// **HTTP Method:** `GET`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .send()
///     .await?;
/// ```
pub fn ip(api: &ApiClient) -> IpRequest<'_> {
    IpRequest::new(api)
}

#[derive(Debug)]
pub struct ReleaseIpRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ReleaseIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::DELETE, "ipam/v1/regions/{region}/ips/{ip_id}")
                .require_path("region")
                .require_path("ip_id")
                .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Release an IP
///
/// Release an IP not currently attached to a resource, and returns it to the available IP pool.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = release_ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn release_ip(api: &ApiClient) -> ReleaseIpRequest<'_> {
    ReleaseIpRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateIpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> UpdateIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PATCH, "ipam/v1/regions/{region}/ips/{ip_id}")
                .require_path("region")
                .require_path("ip_id")
                .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Update an IP
///
/// Update parameters including tags of the specified IP.
///
/// **HTTP Method:** `PATCH`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_ip(api: &ApiClient) -> UpdateIpRequest<'_> {
    UpdateIpRequest::new(api)
}

#[derive(Debug)]
pub struct AttachIpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> AttachIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "ipam/v1/regions/{region}/ips/{ip_id}/attach",
        )
        .require_path("region")
        .require_path("ip_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Attach IP to custom resource
///
/// Attach an existing reserved IP from a Private Network subnet to a custom, named resource via its MAC address. An example of a custom resource is a virtual machine hosted on an Elastic Metal server. Do not use this method for attaching IP addresses to standard Scaleway resources as it will fail - see the relevant product API for an equivalent method.
///
/// **HTTP Method:** `POST`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}/attach`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = attach_ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn attach_ip(api: &ApiClient) -> AttachIpRequest<'_> {
    AttachIpRequest::new(api)
}

#[derive(Debug)]
pub struct DetachIpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> DetachIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "ipam/v1/regions/{region}/ips/{ip_id}/detach",
        )
        .require_path("region")
        .require_path("ip_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Detach IP from a custom resource
///
/// Detach a private IP from a custom resource. An example of a custom resource is a virtual machine hosted on an Elastic Metal server. Do not use this method for detaching IP addresses from standard Scaleway resources (e.g. Instances, Load Balancers) as it will fail - see the relevant product API for an equivalent method.
///
/// **HTTP Method:** `POST`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}/detach`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = detach_ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn detach_ip(api: &ApiClient) -> DetachIpRequest<'_> {
    DetachIpRequest::new(api)
}

#[derive(Debug)]
pub struct MoveIpRequest<'a> {
    builder: ApiRequestBuilder<'a, ScalewayIpamV1Ip>,
}

impl<'a> MoveIpRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "ipam/v1/regions/{region}/ips/{ip_id}/move",
        )
        .require_path("region")
        .require_path("ip_id")
        .require_body();

        Self { builder }
    }
    pub fn with_region(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("region", value);
        self
    }
    pub fn with_ip_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("ip_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<ScalewayIpamV1Ip> {
        self.builder.send().await
    }
}
/// Move IP to a custom resource
///
/// Move an existing reserved private IP from one custom resource (e.g. a virtual machine hosted on an Elastic Metal server) to another custom resource. This will detach it from the first resource, and attach it to the second. Do not use this method for moving IP addresses between standard Scaleway resources (e.g. Instances, Load Balancers) as it will fail - see the relevant product API for an equivalent method.
///
/// **HTTP Method:** `POST`
/// **Path:** `/ipam/v1/regions/{region}/ips/{ip_id}/move`
///
/// **Parameters**
/// - `region` (path, required)
/// - `ip_id` (path, required)
///
/// # Example
/// ```no_run
/// use ipam::{ ApiClient, apis::i_ps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = move_ip(&api)
///     .with_region("region")
///     .with_ip_id("ip_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn move_ip(api: &ApiClient) -> MoveIpRequest<'_> {
    MoveIpRequest::new(api)
}
