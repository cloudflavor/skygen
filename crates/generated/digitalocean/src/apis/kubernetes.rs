// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::associated_kubernetes_resources::AssociatedKubernetesResources;
use crate::models::clusterlint_results::ClusterlintResults;
use crate::models::credentials::Credentials;
use crate::models::error::Error;
use crate::models::kubernetes_options::KubernetesOptions;
use crate::models::user::User;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListClustersRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> ListClustersRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/kubernetes/clusters");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// List All Kubernetes Clusters
///
/// To list all of the Kubernetes clusters on your account, send a GET request
/// to `/v2/kubernetes/clusters`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_clusters(&api)
///     .send()
///     .await?;
/// ```
pub fn list_clusters(api: &ApiClient) -> ListClustersRequest<'_> {
    ListClustersRequest::new(api)
}

#[derive(Debug)]
pub struct CreateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> CreateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "v2/kubernetes/clusters").require_body();

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::cluster::Cluster) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Create a New Kubernetes Cluster
///
/// To create a new Kubernetes cluster, send a POST request to
/// `/v2/kubernetes/clusters`. The request must contain at least one node pool
/// with at least one worker.
///
/// The request may contain a maintenance window policy describing a time period
/// when disruptive maintenance tasks may be carried out. Omitting the policy
/// implies that a window will be chosen automatically. See
/// [here](<https://docs.digitalocean.com/products/kubernetes/how-to/upgrade-cluster/)>
/// for details.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/clusters`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::cluster::Cluster = todo!();
/// let response = create_cluster(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_cluster(api: &ApiClient) -> CreateClusterRequest<'_> {
    CreateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct GetClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "v2/kubernetes/clusters/{cluster_id}")
                .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Retrieve an Existing Kubernetes Cluster
///
/// To show information about an existing Kubernetes cluster, send a GET request
/// to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_cluster(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_cluster(api: &ApiClient) -> GetClusterRequest<'_> {
    GetClusterRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> UpdateClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::PUT, "v2/kubernetes/clusters/{cluster_id}")
                .require_path("cluster_id")
                .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(mut self, body: crate::models::cluster_update::ClusterUpdate) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Update a Kubernetes Cluster
///
/// To update a Kubernetes cluster, send a PUT request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID` and specify one or more of the
/// attributes below.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::cluster_update::ClusterUpdate = todo!();
/// let response = update_cluster(&api)
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_cluster(api: &ApiClient) -> UpdateClusterRequest<'_> {
    UpdateClusterRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::DELETE, "v2/kubernetes/clusters/{cluster_id}")
                .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete a Kubernetes Cluster
///
/// To delete a Kubernetes cluster and all services deployed to it, send a DELETE
/// request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID`.
///
/// A 204 status code with no body will be returned in response to a successful
/// request.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_cluster(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn delete_cluster(api: &ApiClient) -> DeleteClusterRequest<'_> {
    DeleteClusterRequest::new(api)
}

#[derive(Debug)]
pub struct GetClusterLintResultsRequest<'a> {
    builder: ApiRequestBuilder<'a, ClusterlintResults>,
}

impl<'a> GetClusterLintResultsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/clusterlint",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<ClusterlintResults> {
        self.builder.send().await
    }
}
/// Fetch Clusterlint Diagnostics for a Kubernetes Cluster
///
/// To request clusterlint diagnostics for your cluster, send a GET request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/clusterlint`. If the `run_id` query
/// parameter is provided, then the diagnostics for the specific run is fetched.
/// By default, the latest results are shown.
///
/// To find out how to address clusterlint feedback, please refer to
/// [the clusterlint check documentation](<https://github.com/digitalocean/clusterlint/blob/master/checks.md).>
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/clusterlint`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_cluster_lint_results(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_cluster_lint_results(api: &ApiClient) -> GetClusterLintResultsRequest<'_> {
    GetClusterLintResultsRequest::new(api)
}

#[derive(Debug)]
pub struct RunClusterLintRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> RunClusterLintRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/kubernetes/clusters/{cluster_id}/clusterlint",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::clusterlint_request::ClusterlintRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Run Clusterlint Checks on a Kubernetes Cluster
///
/// Clusterlint helps operators conform to Kubernetes best practices around
/// resources, security and reliability to avoid common problems while operating
/// or upgrading the clusters.
///
/// To request a clusterlint run on your cluster, send a POST request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/clusterlint`. This will run all
/// checks present in the `doks` group by default, if a request body is not
/// specified. Optionally specify the below attributes.
///
/// For information about the available checks, please refer to
/// [the clusterlint check documentation](<https://github.com/digitalocean/clusterlint/blob/master/checks.md).>
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/clusterlint`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::clusterlint_request::ClusterlintRequest = todo!();
/// let response = run_cluster_lint(&api)
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn run_cluster_lint(api: &ApiClient) -> RunClusterLintRequest<'_> {
    RunClusterLintRequest::new(api)
}

#[derive(Debug)]
pub struct GetCredentialsRequest<'a> {
    builder: ApiRequestBuilder<'a, Credentials>,
}

impl<'a> GetCredentialsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/credentials",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<Credentials> {
        self.builder.send().await
    }
}
/// Retrieve Credentials for a Kubernetes Cluster
///
/// This endpoint returns a JSON object . It can be used to programmatically
/// construct Kubernetes clients which cannot parse kubeconfig files.
///
/// The resulting JSON object contains token-based authentication for clusters
/// supporting it, and certificate-based authentication otherwise. For a list of
/// supported versions and more information, see "[How to Connect to a DigitalOcean
/// Kubernetes Cluster](<https://docs.digitalocean.com/products/kubernetes/how-to/connect-to-cluster/)".>
///
/// To retrieve credentials for accessing a Kubernetes cluster, send a GET
/// request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/credentials`.
///
/// Clusters supporting token-based authentication may define an expiration by
/// passing a duration in seconds as a query parameter to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/credentials?expiry_seconds=$DURATION_IN_SECONDS`.
/// If not set or 0, then the token will have a 7 day expiry. The query parameter
/// has no impact in certificate-based authentication.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/credentials`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_credentials(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_credentials(api: &ApiClient) -> GetCredentialsRequest<'_> {
    GetCredentialsRequest::new(api)
}

#[derive(Debug)]
pub struct ListAssociatedResourcesRequest<'a> {
    builder: ApiRequestBuilder<'a, AssociatedKubernetesResources>,
}

impl<'a> ListAssociatedResourcesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AssociatedKubernetesResources> {
        self.builder.send().await
    }
}
/// List Associated Resources for Cluster Deletion
///
/// To list the associated billable resources that can be destroyed along with a cluster, send a GET request to the `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/destroy_with_associated_resources` endpoint.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_associated_resources(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn list_associated_resources(api: &ApiClient) -> ListAssociatedResourcesRequest<'_> {
    ListAssociatedResourcesRequest::new(api)
}

#[derive(Debug)]
pub struct DestroyAssociatedResourcesDangerousRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DestroyAssociatedResourcesDangerousRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources/dangerous",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete a Cluster and All of its Associated Resources (Dangerous)
///
/// To delete a Kubernetes cluster with all of its associated resources, send a
/// DELETE request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/destroy_with_associated_resources/dangerous`.
/// A 204 status code with no body will be returned in response to a successful request.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources/dangerous`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = destroy_associated_resources_dangerous(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn destroy_associated_resources_dangerous(
    api: &ApiClient,
) -> DestroyAssociatedResourcesDangerousRequest<'_> {
    DestroyAssociatedResourcesDangerousRequest::new(api)
}

#[derive(Debug)]
pub struct DestroyAssociatedResourcesSelectiveRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DestroyAssociatedResourcesSelectiveRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources/selective",
        )
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::destroy_associated_kubernetes_resources::DestroyAssociatedKubernetesResources,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Selectively Delete a Cluster and its Associated Resources
///
/// To delete a Kubernetes cluster along with a subset of its associated resources,
/// send a DELETE request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/destroy_with_associated_resources/selective`.
///
/// The JSON body of the request should include `load_balancers`, `volumes`, or
/// `volume_snapshots` keys each set to an array of IDs for the associated
/// resources to be destroyed.
///
/// The IDs can be found by querying the cluster's associated resources endpoint.
/// Any associated resource not included in the request will remain and continue
/// to accrue changes on your account.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/destroy_with_associated_resources/selective`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::destroy_associated_kubernetes_resources::DestroyAssociatedKubernetesResources = todo!();
/// let response = destroy_associated_resources_selective(&api)
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn destroy_associated_resources_selective(
    api: &ApiClient,
) -> DestroyAssociatedResourcesSelectiveRequest<'_> {
    DestroyAssociatedResourcesSelectiveRequest::new(api)
}

#[derive(Debug)]
pub struct GetKubeconfigRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetKubeconfigRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/kubeconfig",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Retrieve the kubeconfig for a Kubernetes Cluster
///
/// This endpoint returns a kubeconfig file in YAML format. It can be used to
/// connect to and administer the cluster using the Kubernetes command line tool,
/// `kubectl`, or other programs supporting kubeconfig files (e.g., client libraries).
///
/// The resulting kubeconfig file uses token-based authentication for clusters
/// supporting it, and certificate-based authentication otherwise. For a list of
/// supported versions and more information, see "[How to Connect to a DigitalOcean
/// Kubernetes Cluster](<https://docs.digitalocean.com/products/kubernetes/how-to/connect-to-cluster/)".>
///
/// To retrieve a kubeconfig file for use with a Kubernetes cluster, send a GET
/// request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/kubeconfig`.
///
/// Clusters supporting token-based authentication may define an expiration by
/// passing a duration in seconds as a query parameter to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/kubeconfig?expiry_seconds=$DURATION_IN_SECONDS`.
/// If not set or 0, then the token will have a 7 day expiry. The query parameter
/// has no impact in certificate-based authentication.
///
/// Kubernetes Roles granted to a user with a token-based kubeconfig are derived from that user's
/// DigitalOcean role. Predefined roles (Owner, Member, Modifier etc.) have an automatic mapping
/// to Kubernetes roles. Custom roles are not automatically mapped to any Kubernetes roles,
/// and require [additional configuration](<https://docs.digitalocean.com/products/kubernetes/how-to/set-up-custom-rolebindings/)>
/// by a cluster administrator.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/kubeconfig`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_kubeconfig(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_kubeconfig(api: &ApiClient) -> GetKubeconfigRequest<'_> {
    GetKubeconfigRequest::new(api)
}

#[derive(Debug)]
pub struct ListNodePoolsRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ListNodePoolsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/node_pools",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// List All Node Pools in a Kubernetes Clusters
///
/// To list all of the node pools in a Kubernetes clusters, send a GET request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_node_pools(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn list_node_pools(api: &ApiClient) -> ListNodePoolsRequest<'_> {
    ListNodePoolsRequest::new(api)
}

#[derive(Debug)]
pub struct AddNodePoolRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> AddNodePoolRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/kubernetes/clusters/{cluster_id}/node_pools",
        )
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::kubernetes_node_pool::KubernetesNodePool,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Add a Node Pool to a Kubernetes Cluster
///
/// To add an additional node pool to a Kubernetes clusters, send a POST request
/// to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools` with the following
/// attributes.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::kubernetes_node_pool::KubernetesNodePool = todo!();
/// let response = add_node_pool(&api)
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn add_node_pool(api: &ApiClient) -> AddNodePoolRequest<'_> {
    AddNodePoolRequest::new(api)
}

#[derive(Debug)]
pub struct GetNodePoolRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetNodePoolRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}",
        )
        .require_path("cluster_id")
        .require_path("node_pool_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_node_pool_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_pool_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Retrieve a Node Pool for a Kubernetes Cluster
///
/// To show information about a specific node pool in a Kubernetes cluster, send
/// a GET request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools/$NODE_POOL_ID`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
/// - `node_pool_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_node_pool(&api)
///     .with_cluster_id("cluster_id")
///     .with_node_pool_id("node_pool_id")
///     .send()
///     .await?;
/// ```
pub fn get_node_pool(api: &ApiClient) -> GetNodePoolRequest<'_> {
    GetNodePoolRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateNodePoolRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> UpdateNodePoolRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}",
        )
        .require_path("cluster_id")
        .require_path("node_pool_id")
        .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_node_pool_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_pool_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::kubernetes_node_pool_update::KubernetesNodePoolUpdate,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Update a Node Pool in a Kubernetes Cluster
///
/// To update the name of a node pool, edit the tags applied to it, or adjust its
/// number of nodes, send a PUT request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools/$NODE_POOL_ID` with the
/// following attributes.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
/// - `node_pool_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::kubernetes_node_pool_update::KubernetesNodePoolUpdate = todo!();
/// let response = update_node_pool(&api)
///     .with_cluster_id("cluster_id")
///     .with_node_pool_id("node_pool_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_node_pool(api: &ApiClient) -> UpdateNodePoolRequest<'_> {
    UpdateNodePoolRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteNodePoolRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteNodePoolRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}",
        )
        .require_path("cluster_id")
        .require_path("node_pool_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_node_pool_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_pool_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete a Node Pool in a Kubernetes Cluster
///
/// To delete a node pool, send a DELETE request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools/$NODE_POOL_ID`.
///
/// A 204 status code with no body will be returned in response to a successful
/// request. Nodes in the pool will subsequently be drained and deleted.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
/// - `node_pool_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_node_pool(&api)
///     .with_cluster_id("cluster_id")
///     .with_node_pool_id("node_pool_id")
///     .send()
///     .await?;
/// ```
pub fn delete_node_pool(api: &ApiClient) -> DeleteNodePoolRequest<'_> {
    DeleteNodePoolRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteNodeRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteNodeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}/nodes/{node_id}",
        )
        .require_path("cluster_id")
        .require_path("node_pool_id")
        .require_path("node_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_node_pool_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_pool_id", value);
        self
    }
    pub fn with_node_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete a Node in a Kubernetes Cluster
///
/// To delete a single node in a pool, send a DELETE request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools/$NODE_POOL_ID/nodes/$NODE_ID`.
///
/// Appending the `skip_drain=1` query parameter to the request causes node
/// draining to be skipped. Omitting the query parameter or setting its value to
/// `0` carries out draining prior to deletion.
///
/// Appending the `replace=1` query parameter to the request causes the node to
/// be replaced by a new one after deletion. Omitting the query parameter or
/// setting its value to `0` deletes without replacement.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}/nodes/{node_id}`
///
/// **Parameters**
/// - `cluster_id` (path, required)
/// - `node_pool_id` (path, required)
/// - `node_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_node(&api)
///     .with_cluster_id("cluster_id")
///     .with_node_pool_id("node_pool_id")
///     .with_node_id("node_id")
///     .send()
///     .await?;
/// ```
pub fn delete_node(api: &ApiClient) -> DeleteNodeRequest<'_> {
    DeleteNodeRequest::new(api)
}

#[derive(Debug)]
pub struct RecycleNodePoolRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> RecycleNodePoolRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}/recycle",
        )
        .require_path("cluster_id")
        .require_path("node_pool_id")
        .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_node_pool_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("node_pool_id", value);
        self
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Recycle a Kubernetes Node Pool
///
/// The endpoint has been deprecated. Please use the DELETE
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/node_pools/$NODE_POOL_ID/nodes/$NODE_ID`
/// method instead.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/node_pools/{node_pool_id}/recycle`
///
/// **Parameters**
/// - `cluster_id` (path, required)
/// - `node_pool_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = recycle_node_pool(&api)
///     .with_cluster_id("cluster_id")
///     .with_node_pool_id("node_pool_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn recycle_node_pool(api: &ApiClient) -> RecycleNodePoolRequest<'_> {
    RecycleNodePoolRequest::new(api)
}

#[derive(Debug)]
pub struct GetStatusMessagesRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetStatusMessagesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/status_messages",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Fetch Status Messages for a Kubernetes Cluster
///
/// To retrieve status messages for a Kubernetes cluster, send a GET request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/status_messages`. Status messages inform users of any issues that come up during the cluster lifecycle.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/status_messages`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_status_messages(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_status_messages(api: &ApiClient) -> GetStatusMessagesRequest<'_> {
    GetStatusMessagesRequest::new(api)
}

#[derive(Debug)]
pub struct UpgradeClusterRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> UpgradeClusterRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/kubernetes/clusters/{cluster_id}/upgrade",
        )
        .require_path("cluster_id")
        .require_body();

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub fn with_body(mut self, body: serde_json::Value) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Upgrade a Kubernetes Cluster
///
/// To immediately upgrade a Kubernetes cluster to a newer patch release of
/// Kubernetes, send a POST request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/upgrade`.
/// The body of the request must specify a version attribute.
///
/// Available upgrade versions for a cluster can be fetched from
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/upgrades`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/upgrade`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: serde_json::Value = todo!();
/// let response = upgrade_cluster(&api)
///     .with_cluster_id("cluster_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn upgrade_cluster(api: &ApiClient) -> UpgradeClusterRequest<'_> {
    UpgradeClusterRequest::new(api)
}

#[derive(Debug)]
pub struct GetAvailableUpgradesRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetAvailableUpgradesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/kubernetes/clusters/{cluster_id}/upgrades",
        )
        .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Retrieve Available Upgrades for an Existing Kubernetes Cluster
///
/// To determine whether a cluster can be upgraded, and the versions to which it
/// can be upgraded, send a GET request to
/// `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/upgrades`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/upgrades`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_available_upgrades(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_available_upgrades(api: &ApiClient) -> GetAvailableUpgradesRequest<'_> {
    GetAvailableUpgradesRequest::new(api)
}

#[derive(Debug)]
pub struct GetClusterGetRequest<'a> {
    builder: ApiRequestBuilder<'a, User>,
}

impl<'a> GetClusterGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "v2/kubernetes/clusters/{cluster_id}/user")
                .require_path("cluster_id");

        Self { builder }
    }
    pub fn with_cluster_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("cluster_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<User> {
        self.builder.send().await
    }
}
/// Retrieve User Information for a Kubernetes Cluster
///
/// To show information the user associated with a Kubernetes cluster, send a GET
/// request to `/v2/kubernetes/clusters/$K8S_CLUSTER_ID/user`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/clusters/{cluster_id}/user`
///
/// **Parameters**
/// - `cluster_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_cluster_get(&api)
///     .with_cluster_id("cluster_id")
///     .send()
///     .await?;
/// ```
pub fn get_cluster_get(api: &ApiClient) -> GetClusterGetRequest<'_> {
    GetClusterGetRequest::new(api)
}

#[derive(Debug)]
pub struct ListOptionsRequest<'a> {
    builder: ApiRequestBuilder<'a, KubernetesOptions>,
}

impl<'a> ListOptionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/kubernetes/options");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<KubernetesOptions> {
        self.builder.send().await
    }
}
/// List Available Regions, Node Sizes, and Versions of Kubernetes
///
/// To list the versions of Kubernetes available for use, the regions that support Kubernetes, and the available node sizes, send a GET request to `/v2/kubernetes/options`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/kubernetes/options`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_options(&api)
///     .send()
///     .await?;
/// ```
pub fn list_options(api: &ApiClient) -> ListOptionsRequest<'_> {
    ListOptionsRequest::new(api)
}

#[derive(Debug)]
pub struct AddRegistryRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> AddRegistryRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/kubernetes/registry");

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::cluster_registries::ClusterRegistries) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Add Container Registry to Kubernetes Clusters
///
/// To integrate the container registry with Kubernetes clusters, send a POST request to `/v2/kubernetes/registry`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/kubernetes/registry`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::cluster_registries::ClusterRegistries = todo!();
/// let response = add_registry(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn add_registry(api: &ApiClient) -> AddRegistryRequest<'_> {
    AddRegistryRequest::new(api)
}

#[derive(Debug)]
pub struct RemoveRegistryRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> RemoveRegistryRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::DELETE, "v2/kubernetes/registry");

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::cluster_registries::ClusterRegistries) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Remove Container Registry from Kubernetes Clusters
///
/// To remove the container registry from Kubernetes clusters, send a DELETE request to `/v2/kubernetes/registry`.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/kubernetes/registry`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::kubernetes };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::cluster_registries::ClusterRegistries = todo!();
/// let response = remove_registry(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn remove_registry(api: &ApiClient) -> RemoveRegistryRequest<'_> {
    RemoveRegistryRequest::new(api)
}
