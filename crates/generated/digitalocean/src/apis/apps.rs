// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::app_health_response::AppHealthResponse;
use crate::models::app_instances::AppInstances;
use crate::models::app_metrics_bandwidth_usage::AppMetricsBandwidthUsage;
use crate::models::app_propose_response::AppProposeResponse;
use crate::models::app_response::AppResponse;
use crate::models::apps_alert_response::AppsAlertResponse;
use crate::models::apps_delete_app_response::AppsDeleteAppResponse;
use crate::models::apps_deployment_response::AppsDeploymentResponse;
use crate::models::apps_deployments_response::AppsDeploymentsResponse;
use crate::models::apps_get_exec_response::AppsGetExecResponse;
use crate::models::apps_get_instance_size_response::AppsGetInstanceSizeResponse;
use crate::models::apps_get_logs_response::AppsGetLogsResponse;
use crate::models::apps_list_alerts_response::AppsListAlertsResponse;
use crate::models::apps_list_instance_sizes_response::AppsListInstanceSizesResponse;
use crate::models::apps_list_regions_response::AppsListRegionsResponse;
use crate::models::apps_response::AppsResponse;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct ListRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsResponse>,
}

impl<'a> ListRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<AppsResponse> {
        self.builder.send().await
    }
}
/// List All Apps
///
/// List all apps on your account. Information about the current active deployment as well as any in progress ones will also be included for each app.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list(&api)
///     .send()
///     .await?;
/// ```
pub fn list(api: &ApiClient) -> ListRequest<'_> {
    ListRequest::new(api)
}

#[derive(Debug)]
pub struct CreateRequest<'a> {
    builder: ApiRequestBuilder<'a, AppResponse>,
}

impl<'a> CreateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps").require_body();

        Self { builder }
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_create_app_request::AppsCreateAppRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppResponse> {
        self.builder.send().await
    }
}
/// Create a New App
///
/// Create a new app by submitting an app specification. For documentation on app specifications (`AppSpec` objects), please refer to [the product documentation](<https://docs.digitalocean.com/products/app-platform/reference/app-spec/).>
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_create_app_request::AppsCreateAppRequest = todo!();
/// let response = create(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create(api: &ApiClient) -> CreateRequest<'_> {
    CreateRequest::new(api)
}

#[derive(Debug)]
pub struct ListMetricsBandwidthDailyRequest<'a> {
    builder: ApiRequestBuilder<'a, AppMetricsBandwidthUsage>,
}

impl<'a> ListMetricsBandwidthDailyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/metrics/bandwidth_daily")
            .require_body();

        Self { builder }
    }
    pub fn with_body(
        mut self,
        body: crate::models::app_metrics_bandwidth_usage_request::AppMetricsBandwidthUsageRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppMetricsBandwidthUsage> {
        self.builder.send().await
    }
}
/// Retrieve Multiple Apps' Daily Bandwidth Metrics
///
/// Retrieve daily bandwidth usage metrics for multiple apps.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/metrics/bandwidth_daily`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::app_metrics_bandwidth_usage_request::AppMetricsBandwidthUsageRequest = todo!();
/// let response = list_metrics_bandwidth_daily(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn list_metrics_bandwidth_daily(api: &ApiClient) -> ListMetricsBandwidthDailyRequest<'_> {
    ListMetricsBandwidthDailyRequest::new(api)
}

#[derive(Debug)]
pub struct ValidateAppSpecRequest<'a> {
    builder: ApiRequestBuilder<'a, AppProposeResponse>,
}

impl<'a> ValidateAppSpecRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/propose").require_body();

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::app_propose::AppPropose) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppProposeResponse> {
        self.builder.send().await
    }
}
/// Propose an App Spec
///
/// To propose and validate a spec for a new or existing app, send a POST request to the `/v2/apps/propose` endpoint. The request returns some information about the proposed app, including app cost and upgrade cost. If an existing app ID is specified, the app spec is treated as a proposed update to the existing app.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/propose`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::app_propose::AppPropose = todo!();
/// let response = validate_app_spec(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn validate_app_spec(api: &ApiClient) -> ValidateAppSpecRequest<'_> {
    ValidateAppSpecRequest::new(api)
}

#[derive(Debug)]
pub struct ListRegionsRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsListRegionsResponse>,
}

impl<'a> ListRegionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/regions");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<AppsListRegionsResponse> {
        self.builder.send().await
    }
}
/// List App Regions
///
/// List all regions supported by App Platform.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/regions`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_regions(&api)
///     .send()
///     .await?;
/// ```
pub fn list_regions(api: &ApiClient) -> ListRegionsRequest<'_> {
    ListRegionsRequest::new(api)
}

#[derive(Debug)]
pub struct ListInstanceSizesRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsListInstanceSizesResponse>,
}

impl<'a> ListInstanceSizesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/tiers/instance_sizes");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<AppsListInstanceSizesResponse> {
        self.builder.send().await
    }
}
/// List Instance Sizes
///
/// List all instance sizes for `service`, `worker`, and `job` components.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/tiers/instance_sizes`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_instance_sizes(&api)
///     .send()
///     .await?;
/// ```
pub fn list_instance_sizes(api: &ApiClient) -> ListInstanceSizesRequest<'_> {
    ListInstanceSizesRequest::new(api)
}

#[derive(Debug)]
pub struct GetInstanceSizeRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetInstanceSizeResponse>,
}

impl<'a> GetInstanceSizeRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "v2/apps/tiers/instance_sizes/{slug}")
                .require_path("slug");

        Self { builder }
    }
    pub fn with_slug(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("slug", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetInstanceSizeResponse> {
        self.builder.send().await
    }
}
/// Retrieve an Instance Size
///
/// Retrieve information about a specific instance size for `service`, `worker`, and `job` components.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/tiers/instance_sizes/{slug}`
///
/// **Parameters**
/// - `slug` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_instance_size(&api)
///     .with_slug("slug")
///     .send()
///     .await?;
/// ```
pub fn get_instance_size(api: &ApiClient) -> GetInstanceSizeRequest<'_> {
    GetInstanceSizeRequest::new(api)
}

#[derive(Debug)]
pub struct ListAlertsRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsListAlertsResponse>,
}

impl<'a> ListAlertsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/alerts")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsListAlertsResponse> {
        self.builder.send().await
    }
}
/// List all app alerts
///
/// List alerts associated to the app and any components. This includes configuration information about the alerts including emails, slack webhooks, and triggering events or conditions.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/alerts`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_alerts(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn list_alerts(api: &ApiClient) -> ListAlertsRequest<'_> {
    ListAlertsRequest::new(api)
}

#[derive(Debug)]
pub struct AssignAlertDestinationsRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsAlertResponse>,
}

impl<'a> AssignAlertDestinationsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/apps/{app_id}/alerts/{alert_id}/destinations",
        )
        .require_path("app_id")
        .require_path("alert_id")
        .require_body();

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_alert_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("alert_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_assign_app_alert_destinations_request::AppsAssignAppAlertDestinationsRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppsAlertResponse> {
        self.builder.send().await
    }
}
/// Update destinations for alerts
///
/// Updates the emails and slack webhook destinations for app alerts. Emails must be associated to a user with access to the app.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/alerts/{alert_id}/destinations`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `alert_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_assign_app_alert_destinations_request::AppsAssignAppAlertDestinationsRequest = todo!();
/// let response = assign_alert_destinations(&api)
///     .with_app_id("app_id")
///     .with_alert_id("alert_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn assign_alert_destinations(api: &ApiClient) -> AssignAlertDestinationsRequest<'_> {
    AssignAlertDestinationsRequest::new(api)
}

#[derive(Debug)]
pub struct GetExecActiveDeploymentRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetExecResponse>,
}

impl<'a> GetExecActiveDeploymentRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/components/{component_name}/exec",
        )
        .require_path("app_id")
        .require_path("component_name");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_component_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("component_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetExecResponse> {
        self.builder.send().await
    }
}
/// Retrieve Exec URL
///
/// Returns a websocket URL that allows sending/receiving console input and output to a component of the active deployment if one exists.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/components/{component_name}/exec`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `component_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_exec_active_deployment(&api)
///     .with_app_id("app_id")
///     .with_component_name("component_name")
///     .send()
///     .await?;
/// ```
pub fn get_exec_active_deployment(api: &ApiClient) -> GetExecActiveDeploymentRequest<'_> {
    GetExecActiveDeploymentRequest::new(api)
}

#[derive(Debug)]
pub struct GetLogsActiveDeploymentRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetLogsResponse>,
}

impl<'a> GetLogsActiveDeploymentRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/components/{component_name}/logs",
        )
        .require_path("app_id")
        .require_path("component_name");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_component_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("component_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetLogsResponse> {
        self.builder.send().await
    }
}
/// Retrieve Active Deployment Logs
///
/// Retrieve the logs of the active deployment if one exists. The response will include links to either real-time logs of an in-progress or active deployment or archived logs of a past deployment. Note log_type=BUILD logs will return logs associated with the current active deployment (being served). To view build logs associated with in-progress build, the query must explicitly reference the deployment id.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/components/{component_name}/logs`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `component_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_logs_active_deployment(&api)
///     .with_app_id("app_id")
///     .with_component_name("component_name")
///     .send()
///     .await?;
/// ```
pub fn get_logs_active_deployment(api: &ApiClient) -> GetLogsActiveDeploymentRequest<'_> {
    GetLogsActiveDeploymentRequest::new(api)
}

#[derive(Debug)]
pub struct ListDeploymentsRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentsResponse>,
}

impl<'a> ListDeploymentsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/deployments")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentsResponse> {
        self.builder.send().await
    }
}
/// List App Deployments
///
/// List all deployments of an app.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/deployments`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_deployments(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn list_deployments(api: &ApiClient) -> ListDeploymentsRequest<'_> {
    ListDeploymentsRequest::new(api)
}

#[derive(Debug)]
pub struct CreateDeploymentRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> CreateDeploymentRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/deployments")
            .require_path("app_id")
            .require_body();

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_create_deployment_request::AppsCreateDeploymentRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Create an App Deployment
///
/// Creating an app deployment will pull the latest changes from your repository and schedule a new deployment for your app.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/deployments`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_create_deployment_request::AppsCreateDeploymentRequest = todo!();
/// let response = create_deployment(&api)
///     .with_app_id("app_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_deployment(api: &ApiClient) -> CreateDeploymentRequest<'_> {
    CreateDeploymentRequest::new(api)
}

#[derive(Debug)]
pub struct GetDeploymentRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> GetDeploymentRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/deployments/{deployment_id}",
        )
        .require_path("app_id")
        .require_path("deployment_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_deployment_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("deployment_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Retrieve an App Deployment
///
/// Retrieve information about an app deployment.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/deployments/{deployment_id}`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `deployment_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_deployment(&api)
///     .with_app_id("app_id")
///     .with_deployment_id("deployment_id")
///     .send()
///     .await?;
/// ```
pub fn get_deployment(api: &ApiClient) -> GetDeploymentRequest<'_> {
    GetDeploymentRequest::new(api)
}

#[derive(Debug)]
pub struct CancelDeploymentRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> CancelDeploymentRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/apps/{app_id}/deployments/{deployment_id}/cancel",
        )
        .require_path("app_id")
        .require_path("deployment_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_deployment_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("deployment_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Cancel a Deployment
///
/// Immediately cancel an in-progress deployment.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/deployments/{deployment_id}/cancel`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `deployment_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = cancel_deployment(&api)
///     .with_app_id("app_id")
///     .with_deployment_id("deployment_id")
///     .send()
///     .await?;
/// ```
pub fn cancel_deployment(api: &ApiClient) -> CancelDeploymentRequest<'_> {
    CancelDeploymentRequest::new(api)
}

#[derive(Debug)]
pub struct GetExecRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetExecResponse>,
}

impl<'a> GetExecRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/deployments/{deployment_id}/components/{component_name}/exec",
        )
        .require_path("app_id")
        .require_path("deployment_id")
        .require_path("component_name");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_deployment_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("deployment_id", value);
        self
    }
    pub fn with_component_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("component_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetExecResponse> {
        self.builder.send().await
    }
}
/// Retrieve Exec URL for Deployment
///
/// Returns a websocket URL that allows sending/receiving console input and output to a component of the specified deployment if one exists. Optionally, the instance_name parameter can be provided to retrieve the exec URL for a specific instance. Note that instances are ephemeral; therefore, we recommended to avoid making persistent changes or such scripting around them.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/deployments/{deployment_id}/components/{component_name}/exec`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `deployment_id` (path, required)
/// - `component_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_exec(&api)
///     .with_app_id("app_id")
///     .with_deployment_id("deployment_id")
///     .with_component_name("component_name")
///     .send()
///     .await?;
/// ```
pub fn get_exec(api: &ApiClient) -> GetExecRequest<'_> {
    GetExecRequest::new(api)
}

#[derive(Debug)]
pub struct GetLogsRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetLogsResponse>,
}

impl<'a> GetLogsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/deployments/{deployment_id}/components/{component_name}/logs",
        )
        .require_path("app_id")
        .require_path("deployment_id")
        .require_path("component_name");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_deployment_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("deployment_id", value);
        self
    }
    pub fn with_component_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("component_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetLogsResponse> {
        self.builder.send().await
    }
}
/// Retrieve Deployment Logs
///
/// Retrieve the logs of a past, in-progress, or active deployment. The response will include links to either real-time logs of an in-progress or active deployment or archived logs of a past deployment.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/deployments/{deployment_id}/components/{component_name}/logs`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `deployment_id` (path, required)
/// - `component_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_logs(&api)
///     .with_app_id("app_id")
///     .with_deployment_id("deployment_id")
///     .with_component_name("component_name")
///     .send()
///     .await?;
/// ```
pub fn get_logs(api: &ApiClient) -> GetLogsRequest<'_> {
    GetLogsRequest::new(api)
}

#[derive(Debug)]
pub struct GetLogsAggregateRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetLogsResponse>,
}

impl<'a> GetLogsAggregateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/apps/{app_id}/deployments/{deployment_id}/logs",
        )
        .require_path("app_id")
        .require_path("deployment_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_deployment_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("deployment_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetLogsResponse> {
        self.builder.send().await
    }
}
/// Retrieve Aggregate Deployment Logs
///
/// Retrieve the logs of a past, in-progress, or active deployment. If a component name is specified, the logs will be limited to only that component. The response will include links to either real-time logs of an in-progress or active deployment or archived logs of a past deployment.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/deployments/{deployment_id}/logs`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `deployment_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_logs_aggregate(&api)
///     .with_app_id("app_id")
///     .with_deployment_id("deployment_id")
///     .send()
///     .await?;
/// ```
pub fn get_logs_aggregate(api: &ApiClient) -> GetLogsAggregateRequest<'_> {
    GetLogsAggregateRequest::new(api)
}

#[derive(Debug)]
pub struct GetHealthRequest<'a> {
    builder: ApiRequestBuilder<'a, AppHealthResponse>,
}

impl<'a> GetHealthRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/health")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppHealthResponse> {
        self.builder.send().await
    }
}
/// Retrieve App Health
///
/// Retrieve information like health status, cpu and memory utilization of app components.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/health`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_health(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn get_health(api: &ApiClient) -> GetHealthRequest<'_> {
    GetHealthRequest::new(api)
}

#[derive(Debug)]
pub struct GetInstancesRequest<'a> {
    builder: ApiRequestBuilder<'a, AppInstances>,
}

impl<'a> GetInstancesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/instances")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppInstances> {
        self.builder.send().await
    }
}
/// Retrieve App Instances
///
/// Retrieve the list of running instances for a given application, including instance names and component types. Please note that these instances are ephemeral and may change over time. It is recommended not to make persistent changes or develop scripts that rely on their persistence.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/instances`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_instances(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn get_instances(api: &ApiClient) -> GetInstancesRequest<'_> {
    GetInstancesRequest::new(api)
}

#[derive(Debug)]
pub struct GetLogsActiveDeploymentGetRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsGetLogsResponse>,
}

impl<'a> GetLogsActiveDeploymentGetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/logs")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsGetLogsResponse> {
        self.builder.send().await
    }
}
/// Retrieve Active Deployment Aggregate Logs
///
/// Retrieve the logs of the active deployment if one exists. The response will include links to either real-time logs of an in-progress or active deployment or archived logs of a past deployment. Note log_type=BUILD logs will return logs associated with the current active deployment (being served). To view build logs associated with in-progress build, the query must explicitly reference the deployment id.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/logs`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_logs_active_deployment_get(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn get_logs_active_deployment_get(api: &ApiClient) -> GetLogsActiveDeploymentGetRequest<'_> {
    GetLogsActiveDeploymentGetRequest::new(api)
}

#[derive(Debug)]
pub struct GetMetricsBandwidthDailyRequest<'a> {
    builder: ApiRequestBuilder<'a, AppMetricsBandwidthUsage>,
}

impl<'a> GetMetricsBandwidthDailyRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "v2/apps/{app_id}/metrics/bandwidth_daily")
                .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_date(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.header_param("date", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppMetricsBandwidthUsage> {
        self.builder.send().await
    }
}
/// Retrieve App Daily Bandwidth Metrics
///
/// Retrieve daily bandwidth usage metrics for a single app.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{app_id}/metrics/bandwidth_daily`
///
/// **Parameters**
/// - `app_id` (path, required)
/// - `date` (query,optional)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_metrics_bandwidth_daily(&api)
///     .with_app_id("app_id")
///     .with_date("date")
///     .send()
///     .await?;
/// ```
pub fn get_metrics_bandwidth_daily(api: &ApiClient) -> GetMetricsBandwidthDailyRequest<'_> {
    GetMetricsBandwidthDailyRequest::new(api)
}

#[derive(Debug)]
pub struct RestartRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> RestartRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/restart")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_restart_request::AppsRestartRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Restart an App
///
/// Perform a rolling restart of all or specific components in an app.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/restart`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_restart_request::AppsRestartRequest = todo!();
/// let response = restart(&api)
///     .with_app_id("app_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn restart(api: &ApiClient) -> RestartRequest<'_> {
    RestartRequest::new(api)
}

#[derive(Debug)]
pub struct CreateRollbackRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> CreateRollbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/rollback")
            .require_path("app_id")
            .require_body();

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_rollback_app_request::AppsRollbackAppRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Rollback App
///
/// Rollback an app to a previous deployment. A new deployment will be created to perform the rollback.
/// The app will be pinned to the rollback deployment preventing any new deployments from being created,
/// either manually or through Auto Deploy on Push webhooks. To resume deployments, the rollback must be
/// either committed or reverted.
///
/// It is recommended to use the Validate App Rollback endpoint to double check if the rollback is
/// valid and if there are any warnings.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/rollback`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_rollback_app_request::AppsRollbackAppRequest = todo!();
/// let response = create_rollback(&api)
///     .with_app_id("app_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create_rollback(api: &ApiClient) -> CreateRollbackRequest<'_> {
    CreateRollbackRequest::new(api)
}

#[derive(Debug)]
pub struct CommitRollbackRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> CommitRollbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/rollback/commit")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Commit App Rollback
///
/// Commit an app rollback. This action permanently applies the rollback and unpins the app to resume new deployments.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/rollback/commit`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = commit_rollback(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn commit_rollback(api: &ApiClient) -> CommitRollbackRequest<'_> {
    CommitRollbackRequest::new(api)
}

#[derive(Debug)]
pub struct RevertRollbackRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeploymentResponse>,
}

impl<'a> RevertRollbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/rollback/revert")
            .require_path("app_id");

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeploymentResponse> {
        self.builder.send().await
    }
}
/// Revert App Rollback
///
/// Revert an app rollback. This action reverts the active rollback by creating a new deployment from the
/// latest app spec prior to the rollback and unpins the app to resume new deployments.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/rollback/revert`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = revert_rollback(&api)
///     .with_app_id("app_id")
///     .send()
///     .await?;
/// ```
pub fn revert_rollback(api: &ApiClient) -> RevertRollbackRequest<'_> {
    RevertRollbackRequest::new(api)
}

#[derive(Debug)]
pub struct ValidateRollbackRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> ValidateRollbackRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "v2/apps/{app_id}/rollback/validate")
                .require_path("app_id")
                .require_body();

        Self { builder }
    }
    pub fn with_app_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("app_id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_rollback_app_request::AppsRollbackAppRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Validate App Rollback
///
/// Check whether an app can be rolled back to a specific deployment. This endpoint can also be used
/// to check if there are any warnings or validation conditions that will cause the rollback to proceed
/// under unideal circumstances. For example, if a component must be rebuilt as part of the rollback
/// causing it to take longer than usual.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/apps/{app_id}/rollback/validate`
///
/// **Parameters**
/// - `app_id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_rollback_app_request::AppsRollbackAppRequest = todo!();
/// let response = validate_rollback(&api)
///     .with_app_id("app_id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn validate_rollback(api: &ApiClient) -> ValidateRollbackRequest<'_> {
    ValidateRollbackRequest::new(api)
}

#[derive(Debug)]
pub struct GetRequest<'a> {
    builder: ApiRequestBuilder<'a, AppResponse>,
}

impl<'a> GetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/apps/{id}").require_path("id");

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppResponse> {
        self.builder.send().await
    }
}
/// Retrieve an Existing App
///
/// Retrieve details about an existing app by either its ID or name. To retrieve an app by its name, do not include an ID in the request path. Information about the current active deployment as well as any in progress ones will also be included in the response.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/apps/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get(&api)
///     .with_id("id")
///     .send()
///     .await?;
/// ```
pub fn get(api: &ApiClient) -> GetRequest<'_> {
    GetRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateRequest<'a> {
    builder: ApiRequestBuilder<'a, AppResponse>,
}

impl<'a> UpdateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::PUT, "v2/apps/{id}")
            .require_path("id")
            .require_body();

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub fn with_body(
        mut self,
        body: crate::models::apps_update_app_request::AppsUpdateAppRequest,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<AppResponse> {
        self.builder.send().await
    }
}
/// Update an App
///
/// Update an existing app by submitting a new app specification. For documentation on app specifications (`AppSpec` objects), please refer to [the product documentation](<https://docs.digitalocean.com/products/app-platform/reference/app-spec/).>
///
/// **HTTP Method:** `PUT`
/// **Path:** `/v2/apps/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::apps_update_app_request::AppsUpdateAppRequest = todo!();
/// let response = update(&api)
///     .with_id("id")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update(api: &ApiClient) -> UpdateRequest<'_> {
    UpdateRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, AppsDeleteAppResponse>,
}

impl<'a> DeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::DELETE, "v2/apps/{id}").require_path("id");

        Self { builder }
    }
    pub fn with_id(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("id", value);
        self
    }
    pub async fn send(self) -> ApiResult<AppsDeleteAppResponse> {
        self.builder.send().await
    }
}
/// Delete an App
///
/// Delete an existing app. Once deleted, all active deployments will be permanently shut down and the app deleted. If needed, be sure to back up your app specification so that you may re-create it at a later time.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/apps/{id}`
///
/// **Parameters**
/// - `id` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::apps };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete(&api)
///     .with_id("id")
///     .send()
///     .await?;
/// ```
pub fn delete(api: &ApiClient) -> DeleteRequest<'_> {
    DeleteRequest::new(api)
}
