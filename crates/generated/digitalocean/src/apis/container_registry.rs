// Auto-generated by codegen - Skygen
// https://cloudflavor.io/projects/skygen
//
// Copyright 2025 Cloudflavor GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::models::docker_credentials::DockerCredentials;
use crate::models::error::Error;
use crate::{ApiClient, ApiRequestBuilder, ApiResult};
use reqwest::Method;

#[derive(Debug)]
pub struct GetRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/registry");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Get Container Registry Information
///
/// To get information about your container registry, send a GET request to `/v2/registry`.
/// This operation is not compatible with multiple registries in a DO account. You should use `/v2/registries/{registry_name}` instead.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get(&api)
///     .send()
///     .await?;
/// ```
pub fn get(api: &ApiClient) -> GetRequest<'_> {
    GetRequest::new(api)
}

#[derive(Debug)]
pub struct CreateRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> CreateRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/registry").require_body();

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::registry_create::RegistryCreate) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Create Container Registry
///
/// To create your container registry, send a POST request to `/v2/registry`.
///
/// The `name` becomes part of the URL for images stored in the registry. For
/// example, if your registry is called `example`, an image in it will have the
/// URL `registry.digitalocean.com/example/image:tag`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/registry`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::registry_create::RegistryCreate = todo!();
/// let response = create(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn create(api: &ApiClient) -> CreateRequest<'_> {
    CreateRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::DELETE, "v2/registry");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete Container Registry
///
/// To delete your container registry, destroying all container image data stored in it, send a DELETE request to `/v2/registry`.
/// This operation is not compatible with multiple registries in a DO account. You should use `/v2/registries/{registry_name}` instead.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/registry`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete(&api)
///     .send()
///     .await?;
/// ```
pub fn delete(api: &ApiClient) -> DeleteRequest<'_> {
    DeleteRequest::new(api)
}

#[derive(Debug)]
pub struct GetDockerCredentialsRequest<'a> {
    builder: ApiRequestBuilder<'a, DockerCredentials>,
}

impl<'a> GetDockerCredentialsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/registry/docker-credentials");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<DockerCredentials> {
        self.builder.send().await
    }
}
/// Get Docker Credentials for Container Registry
///
/// In order to access your container registry with the Docker client or from a
/// Kubernetes cluster, you will need to configure authentication. The necessary
/// JSON configuration can be retrieved by sending a GET request to
/// `/v2/registry/docker-credentials`.
///
/// The response will be in the format of a Docker `config.json` file. To use the
/// config in your Kubernetes cluster, create a Secret with:
///
/// kubectl create secret generic docr \
/// --from-file=.dockerconfigjson=config.json \
/// --type=kubernetes.io/dockerconfigjson
///
/// By default, the returned credentials have read-only access to your registry
/// and cannot be used to push images. This is appropriate for most Kubernetes
/// clusters. To retrieve read/write credentials, suitable for use with the Docker
/// client or in a CI system, read_write may be provided as query parameter. For
/// example: `/v2/registry/docker-credentials?read_write=true`
///
/// By default, the returned credentials will not expire. To retrieve credentials
/// with an expiry set, expiry_seconds may be provided as a query parameter. For
/// example: `/v2/registry/docker-credentials?expiry_seconds=3600` will return
/// credentials that expire after one hour.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/docker-credentials`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_docker_credentials(&api)
///     .send()
///     .await?;
/// ```
pub fn get_docker_credentials(api: &ApiClient) -> GetDockerCredentialsRequest<'_> {
    GetDockerCredentialsRequest::new(api)
}

#[derive(Debug)]
pub struct GetOptionsRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetOptionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/registry/options");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// List Registry Options (Subscription Tiers and Available Regions)
///
/// This endpoint serves to provide additional information as to which option values are available when creating a container registry.
/// There are multiple subscription tiers available for container registry. Each tier allows a different number of image repositories to be created in your registry, and has a different amount of storage and transfer included.
/// There are multiple regions available for container registry and controls where your data is stored.
/// To list the available options, send a GET request to `/v2/registry/options`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/options`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_options(&api)
///     .send()
///     .await?;
/// ```
pub fn get_options(api: &ApiClient) -> GetOptionsRequest<'_> {
    GetOptionsRequest::new(api)
}

#[derive(Debug)]
pub struct GetSubscriptionRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> GetSubscriptionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::GET, "v2/registry/subscription");

        Self { builder }
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Get Subscription Information
///
/// A subscription is automatically created when you configure your container registry. To get information about your subscription, send a GET request to `/v2/registry/subscription`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/subscription`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_subscription(&api)
///     .send()
///     .await?;
/// ```
pub fn get_subscription(api: &ApiClient) -> GetSubscriptionRequest<'_> {
    GetSubscriptionRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateSubscriptionRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> UpdateSubscriptionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(api, Method::POST, "v2/registry/subscription");

        Self { builder }
    }
    pub fn with_body(
        mut self,
        body: std::collections::BTreeMap<String, serde_json::Value>,
    ) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// Update Subscription Tier
///
/// After creating your registry, you can switch to a different subscription tier to better suit your needs. To do this, send a POST request to `/v2/registry/subscription`.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/registry/subscription`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: std::collections::BTreeMap<String, serde_json::Value> = todo!();
/// let response = update_subscription(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_subscription(api: &ApiClient) -> UpdateSubscriptionRequest<'_> {
    UpdateSubscriptionRequest::new(api)
}

#[derive(Debug)]
pub struct ValidateNameRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> ValidateNameRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::POST, "v2/registry/validate-name").require_body();

        Self { builder }
    }
    pub fn with_body(mut self, body: crate::models::validate_registry::ValidateRegistry) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Validate a Container Registry Name
///
/// To validate that a container registry name is available for use, send a POST
/// request to `/v2/registry/validate-name`.
///
/// If the name is both formatted correctly and available, the response code will
/// be 204 and contain no body. If the name is already in use, the response will
/// be a 409 Conflict.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/registry/validate-name`
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::validate_registry::ValidateRegistry = todo!();
/// let response = validate_name(&api)
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn validate_name(api: &ApiClient) -> ValidateNameRequest<'_> {
    ValidateNameRequest::new(api)
}

#[derive(Debug)]
pub struct GetGarbageCollectionRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> GetGarbageCollectionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/registry/{registry_name}/garbage-collection",
        )
        .require_path("registry_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Get Active Garbage Collection
///
/// To get information about the currently-active garbage collection for a registry, send a GET request to `/v2/registry/$REGISTRY_NAME/garbage-collection`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/garbage-collection`
///
/// **Parameters**
/// - `registry_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = get_garbage_collection(&api)
///     .with_registry_name("registry_name")
///     .send()
///     .await?;
/// ```
pub fn get_garbage_collection(api: &ApiClient) -> GetGarbageCollectionRequest<'_> {
    GetGarbageCollectionRequest::new(api)
}

#[derive(Debug)]
pub struct RunGarbageCollectionRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> RunGarbageCollectionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::POST,
            "v2/registry/{registry_name}/garbage-collection",
        )
        .require_path("registry_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_body(mut self, body: crate::models::registry_run_gc::RegistryRunGc) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Start Garbage Collection
///
/// Garbage collection enables users to clear out unreferenced blobs (layer &
/// manifest data) after deleting one or more manifests from a repository. If
/// there are no unreferenced blobs resulting from the deletion of one or more
/// manifests, garbage collection is effectively a noop.
/// [See here for more information](<https://docs.digitalocean.com/products/container-registry/how-to/clean-up-container-registry/)>
/// about how and why you should clean up your container registry periodically.
///
/// To request a garbage collection run on your registry, send a POST request to
/// `/v2/registry/$REGISTRY_NAME/garbage-collection`. This will initiate the
/// following sequence of events on your registry.
///
/// * Set the registry to read-only mode, meaning no further write-scoped
/// JWTs will be issued to registry clients. Existing write-scoped JWTs will
/// continue to work until they expire which can take up to 15 minutes.
/// * Wait until all existing write-scoped JWTs have expired.
/// * Scan all registry manifests to determine which blobs are unreferenced.
/// * Delete all unreferenced blobs from the registry.
/// * Record the number of blobs deleted and bytes freed, mark the garbage
/// collection status as `success`.
/// * Remove the read-only mode restriction from the registry, meaning write-scoped
/// JWTs will once again be issued to registry clients.
///
/// **HTTP Method:** `POST`
/// **Path:** `/v2/registry/{registry_name}/garbage-collection`
///
/// **Parameters**
/// - `registry_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::registry_run_gc::RegistryRunGc = todo!();
/// let response = run_garbage_collection(&api)
///     .with_registry_name("registry_name")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn run_garbage_collection(api: &ApiClient) -> RunGarbageCollectionRequest<'_> {
    RunGarbageCollectionRequest::new(api)
}

#[derive(Debug)]
pub struct UpdateGarbageCollectionRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> UpdateGarbageCollectionRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::PUT,
            "v2/registry/{registry_name}/garbage-collection/{garbage_collection_uuid}",
        )
        .require_path("registry_name")
        .require_path("garbage_collection_uuid")
        .require_body();

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_garbage_collection_uuid(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("garbage_collection_uuid", value);
        self
    }
    pub fn with_body(mut self, body: crate::models::update_registry::UpdateRegistry) -> Self {
        self.builder = self.builder.json_body(body).expect("body serialization");
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// Update Garbage Collection
///
/// To cancel the currently-active garbage collection for a registry, send a PUT request to `/v2/registry/$REGISTRY_NAME/garbage-collection/$GC_UUID` and specify one or more of the attributes below.
///
/// **HTTP Method:** `PUT`
/// **Path:** `/v2/registry/{registry_name}/garbage-collection/{garbage_collection_uuid}`
///
/// **Parameters**
/// - `registry_name` (path, required)
/// - `garbage_collection_uuid` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// # let body: crate::models::update_registry::UpdateRegistry = todo!();
/// let response = update_garbage_collection(&api)
///     .with_registry_name("registry_name")
///     .with_garbage_collection_uuid("garbage_collection_uuid")
///     .with_body(body)
///     .send()
///     .await?;
/// ```
pub fn update_garbage_collection(api: &ApiClient) -> UpdateGarbageCollectionRequest<'_> {
    UpdateGarbageCollectionRequest::new(api)
}

#[derive(Debug)]
pub struct ListGarbageCollectionsRequest<'a> {
    builder: ApiRequestBuilder<'a, std::collections::BTreeMap<String, serde_json::Value>>,
}

impl<'a> ListGarbageCollectionsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/registry/{registry_name}/garbage-collections",
        )
        .require_path("registry_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<std::collections::BTreeMap<String, serde_json::Value>> {
        self.builder.send().await
    }
}
/// List Garbage Collections
///
/// To get information about past garbage collections for a registry, send a GET request to `/v2/registry/$REGISTRY_NAME/garbage-collections`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/garbage-collections`
///
/// **Parameters**
/// - `registry_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_garbage_collections(&api)
///     .with_registry_name("registry_name")
///     .send()
///     .await?;
/// ```
pub fn list_garbage_collections(api: &ApiClient) -> ListGarbageCollectionsRequest<'_> {
    ListGarbageCollectionsRequest::new(api)
}

#[derive(Debug)]
pub struct ListRepositoriesRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ListRepositoriesRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder =
            ApiRequestBuilder::new(api, Method::GET, "v2/registry/{registry_name}/repositories")
                .require_path("registry_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// List All Container Registry Repositories
///
/// This endpoint has been deprecated in favor of the _List All Container Registry Repositories [V2]_ endpoint.
///
/// To list all repositories in your container registry, send a GET
/// request to `/v2/registry/$REGISTRY_NAME/repositories`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/repositories`
///
/// **Parameters**
/// - `registry_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_repositories(&api)
///     .with_registry_name("registry_name")
///     .send()
///     .await?;
/// ```
pub fn list_repositories(api: &ApiClient) -> ListRepositoriesRequest<'_> {
    ListRepositoriesRequest::new(api)
}

#[derive(Debug)]
pub struct ListRepositoryManifestsRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ListRepositoryManifestsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/registry/{registry_name}/repositories/{repository_name}/digests",
        )
        .require_path("registry_name")
        .require_path("repository_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_repository_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("repository_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// List All Container Registry Repository Manifests
///
/// To list all manifests in your container registry repository, send a GET
/// request to `/v2/registry/$REGISTRY_NAME/repositories/$REPOSITORY_NAME/digests`.
///
/// Note that if your repository name contains `/` characters, it must be
/// URL-encoded in the request URL. For example, to list manifests for
/// `registry.digitalocean.com/example/my/repo`, the path would be
/// `/v2/registry/example/repositories/my%2Frepo/digests`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/repositories/{repository_name}/digests`
///
/// **Parameters**
/// - `registry_name` (path, required)
/// - `repository_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_repository_manifests(&api)
///     .with_registry_name("registry_name")
///     .with_repository_name("repository_name")
///     .send()
///     .await?;
/// ```
pub fn list_repository_manifests(api: &ApiClient) -> ListRepositoryManifestsRequest<'_> {
    ListRepositoryManifestsRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteRepositoryManifestRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteRepositoryManifestRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/registry/{registry_name}/repositories/{repository_name}/digests/{manifest_digest}",
        )
        .require_path("registry_name")
        .require_path("repository_name")
        .require_path("manifest_digest");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_repository_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("repository_name", value);
        self
    }
    pub fn with_manifest_digest(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("manifest_digest", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete Container Registry Repository Manifest
///
/// To delete a container repository manifest by digest, send a DELETE request to
/// `/v2/registry/$REGISTRY_NAME/repositories/$REPOSITORY_NAME/digests/$MANIFEST_DIGEST`.
///
/// Note that if your repository name contains `/` characters, it must be
/// URL-encoded in the request URL. For example, to delete
/// `registry.digitalocean.com/example/my/repo@sha256:abcd`, the path would be
/// `/v2/registry/example/repositories/my%2Frepo/digests/sha256:abcd`.
///
/// A successful request will receive a 204 status code with no body in response.
/// This indicates that the request was processed successfully.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/registry/{registry_name}/repositories/{repository_name}/digests/{manifest_digest}`
///
/// **Parameters**
/// - `registry_name` (path, required)
/// - `repository_name` (path, required)
/// - `manifest_digest` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_repository_manifest(&api)
///     .with_registry_name("registry_name")
///     .with_repository_name("repository_name")
///     .with_manifest_digest("manifest_digest")
///     .send()
///     .await?;
/// ```
pub fn delete_repository_manifest(api: &ApiClient) -> DeleteRepositoryManifestRequest<'_> {
    DeleteRepositoryManifestRequest::new(api)
}

#[derive(Debug)]
pub struct ListRepositoryTagsRequest<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ListRepositoryTagsRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/registry/{registry_name}/repositories/{repository_name}/tags",
        )
        .require_path("registry_name")
        .require_path("repository_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_repository_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("repository_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// List All Container Registry Repository Tags
///
/// To list all tags in your container registry repository, send a GET
/// request to `/v2/registry/$REGISTRY_NAME/repositories/$REPOSITORY_NAME/tags`.
///
/// Note that if your repository name contains `/` characters, it must be
/// URL-encoded in the request URL. For example, to list tags for
/// `registry.digitalocean.com/example/my/repo`, the path would be
/// `/v2/registry/example/repositories/my%2Frepo/tags`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/repositories/{repository_name}/tags`
///
/// **Parameters**
/// - `registry_name` (path, required)
/// - `repository_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_repository_tags(&api)
///     .with_registry_name("registry_name")
///     .with_repository_name("repository_name")
///     .send()
///     .await?;
/// ```
pub fn list_repository_tags(api: &ApiClient) -> ListRepositoryTagsRequest<'_> {
    ListRepositoryTagsRequest::new(api)
}

#[derive(Debug)]
pub struct DeleteRepositoryTagRequest<'a> {
    builder: ApiRequestBuilder<'a, Error>,
}

impl<'a> DeleteRepositoryTagRequest<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::DELETE,
            "v2/registry/{registry_name}/repositories/{repository_name}/tags/{repository_tag}",
        )
        .require_path("registry_name")
        .require_path("repository_name")
        .require_path("repository_tag");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub fn with_repository_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("repository_name", value);
        self
    }
    pub fn with_repository_tag(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("repository_tag", value);
        self
    }
    pub async fn send(self) -> ApiResult<Error> {
        self.builder.send().await
    }
}
/// Delete Container Registry Repository Tag
///
/// To delete a container repository tag, send a DELETE request to
/// `/v2/registry/$REGISTRY_NAME/repositories/$REPOSITORY_NAME/tags/$TAG`.
///
/// Note that if your repository name contains `/` characters, it must be
/// URL-encoded in the request URL. For example, to delete
/// `registry.digitalocean.com/example/my/repo:mytag`, the path would be
/// `/v2/registry/example/repositories/my%2Frepo/tags/mytag`.
///
/// A successful request will receive a 204 status code with no body in response.
/// This indicates that the request was processed successfully.
///
/// **HTTP Method:** `DELETE`
/// **Path:** `/v2/registry/{registry_name}/repositories/{repository_name}/tags/{repository_tag}`
///
/// **Parameters**
/// - `registry_name` (path, required)
/// - `repository_name` (path, required)
/// - `repository_tag` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = delete_repository_tag(&api)
///     .with_registry_name("registry_name")
///     .with_repository_name("repository_name")
///     .with_repository_tag("repository_tag")
///     .send()
///     .await?;
/// ```
pub fn delete_repository_tag(api: &ApiClient) -> DeleteRepositoryTagRequest<'_> {
    DeleteRepositoryTagRequest::new(api)
}

#[derive(Debug)]
pub struct ListRepositoriesV2Request<'a> {
    builder: ApiRequestBuilder<'a, serde_json::Value>,
}

impl<'a> ListRepositoriesV2Request<'a> {
    pub fn new(api: &'a ApiClient) -> Self {
        let builder = ApiRequestBuilder::new(
            api,
            Method::GET,
            "v2/registry/{registry_name}/repositoriesV2",
        )
        .require_path("registry_name");

        Self { builder }
    }
    pub fn with_registry_name(mut self, value: impl Into<String>) -> Self {
        self.builder = self.builder.path_param("registry_name", value);
        self
    }
    pub async fn send(self) -> ApiResult<serde_json::Value> {
        self.builder.send().await
    }
}
/// List All Container Registry Repositories (V2)
///
/// To list all repositories in your container registry, send a GET request to `/v2/registry/$REGISTRY_NAME/repositoriesV2`.
///
/// **HTTP Method:** `GET`
/// **Path:** `/v2/registry/{registry_name}/repositoriesV2`
///
/// **Parameters**
/// - `registry_name` (path, required)
///
/// # Example
/// ```no_run
/// use digitalocean::{ ApiClient, apis::container_registry };
/// let api = ApiClient::builder("https://api.example.com").build().expect("client");
/// let response = list_repositories_v2(&api)
///     .with_registry_name("registry_name")
///     .send()
///     .await?;
/// ```
pub fn list_repositories_v2(api: &ApiClient) -> ListRepositoriesV2Request<'_> {
    ListRepositoriesV2Request::new(api)
}
